Directory Structure:

└── ./
    ├── docs
    │   └── chat-bot-help.md
    ├── Moblin
    │   ├── Media
    │   │   └── HaishinKit
    │   │       └── Vendor
    │   │           └── SRT
    │   │               └── libsrt.xcframework
    │   │                   └── Info.plist
    │   ├── Platforms
    │   │   ├── Kick
    │   │   │   ├── KickChannel.swift
    │   │   │   ├── KickPusher.swift
    │   │   │   └── KickViewers.swift
    │   │   ├── Twitch
    │   │   │   └── TwitchChatMoblin.swift
    │   │   └── YouTube
    │   │       └── YouTubeLiveChat.swift
    │   ├── Various
    │   │   ├── AlertMediaStorage.swift
    │   │   ├── ChatBotCommand.swift
    │   │   ├── ChatTextToSpeech.swift
    │   │   ├── WebSocetClient.swift
    │   │   └── WebSocketClient.swift
    │   ├── View
    │   │   ├── ControlBar
    │   │   │   └── QuickButton
    │   │   │       └── QuickButtonChatView.swift
    │   │   ├── Settings
    │   │   │   ├── Chat
    │   │   │   │   ├── ChatBotSettingsView.swift
    │   │   │   │   ├── ChatSettingsView.swift
    │   │   │   │   ├── ChatTextToSpeechSettingsView.swift
    │   │   │   │   └── ChatUsernamesToIgnoreSettingsView.swift
    │   │   │   ├── Streams
    │   │   │   │   └── Stream
    │   │   │   │       ├── Chat
    │   │   │   │       │   └── StreamEmotesSettingsView.swift
    │   │   │   │       ├── Kick
    │   │   │   │       │   └── StreamKickSettingsView.swift
    │   │   │   │       └── Wizard
    │   │   │   │           ├── Platform
    │   │   │   │           │   └── StreamWizardKickSettingsView.swift
    │   │   │   │           └── StreamWizardChatSettingsView.swift
    │   │   │   └── Watch
    │   │   │       └── Chat
    │   │   │           └── WatchChatSettingsView.swift
    │   │   └── Stream
    │   │       └── Overlay
    │   │           └── StreamOverlayChatView.swift
    │   └── Info.plist
    ├── Moblin Screen Recording
    │   └── Info.plist
    ├── Moblin Watch
    │   ├── View
    │   │   └── Chat
    │   │       └── ChatView.swift
    │   └── Info.plist
    ├── Moblin Widget
    │   └── Info.plist
    ├── Moblin.xcodeproj
    │   └── project.xcworkspace
    │       └── xcshareddata
    │           └── IDEWorkspaceChecks.plist
    └── utils
        ├── assistant.py
        ├── bitrate.py
        ├── translate.py
        └── xliff.py



---
File: /docs/chat-bot-help.md
---

# Moblin chat bot help

| Command | Description |
|---------|-------------|
| !moblin obs fix   | Fix OBS input.        |
| !moblin alert \<name> | Trigger alerts. Configure alert names in alert widgets. |
| !moblin fax \<url> | Fax the streamer images. |
| !moblin snapshot | Take snapshot. |
| !moblin snapshot \<message> | Take snapshot showing given message to the streamer. |
| !moblin map zoom out | Zoom out map widget temporarily. |
| !moblin tts on | Turn on chat text to speech. |
| !moblin tts off | Turn off chat text to speech. |
| !moblin say \<message> | Say given message. |
| !moblin mute | Mute audio. |
| !moblin unmute | Unmute audio. |
| !moblin tesla trunk open | Open the trunk. |
| !moblin tesla trunk close | Close the trunk. |
| !moblin tesla media next | Next track. |
| !moblin tesla media previous | Previous track. |
| !moblin tesla media toggle-playback | Toggle playback. |
| !moblin filter movie on | Turn on the movie filter. |
| !moblin filter movie off | Turn off the movie filter. |
| !moblin filter grayscale on | Turn on the grayscale filter. |
| !moblin filter grayscale off | Turn off the grayscale filter. |
| !moblin filter sepia on | Turn on the sepia filter. |
| !moblin filter sepia off | Turn off the sepia filter. |
| !moblin filter triple on | Turn on the triple filter. |
| !moblin filter triple off | Turn off the triple filter. |
| !moblin filter pixellate on | Turn on the pixellate filter. |
| !moblin filter pixellate off | Turn off the pixellate filter. |
| !moblin filter 4:3 on | Turn on the 4:3 filter. |
| !moblin filter 4:3 off | Turn off the 4:3 filter. |



---
File: /Moblin/Media/HaishinKit/Vendor/SRT/libsrt.xcframework/Info.plist
---

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>AvailableLibraries</key>
	<array>
		<dict>
			<key>BinaryPath</key>
			<string>libsrt.a</string>
			<key>HeadersPath</key>
			<string>Headers</string>
			<key>LibraryIdentifier</key>
			<string>ios-arm64_x86_64-simulator</string>
			<key>LibraryPath</key>
			<string>libsrt.a</string>
			<key>SupportedArchitectures</key>
			<array>
				<string>arm64</string>
				<string>x86_64</string>
			</array>
			<key>SupportedPlatform</key>
			<string>ios</string>
			<key>SupportedPlatformVariant</key>
			<string>simulator</string>
		</dict>
		<dict>
			<key>BinaryPath</key>
			<string>libsrt.a</string>
			<key>HeadersPath</key>
			<string>Headers</string>
			<key>LibraryIdentifier</key>
			<string>ios-arm64</string>
			<key>LibraryPath</key>
			<string>libsrt.a</string>
			<key>SupportedArchitectures</key>
			<array>
				<string>arm64</string>
			</array>
			<key>SupportedPlatform</key>
			<string>ios</string>
		</dict>
	</array>
	<key>CFBundlePackageType</key>
	<string>XFWK</string>
	<key>XCFrameworkFormatVersion</key>
	<string>1.0</string>
</dict>
</plist>



---
File: /Moblin/Platforms/Kick/KickChannel.swift
---

import Foundation

struct KickLivestream: Codable {
    // periphery:ignore
    let id: Int
    let viewers: Int
}

struct KickChatroom: Codable {
    let id: Int
}

struct KickChannel: Codable {
    // periphery:ignore
    let slug: String
    let chatroom: KickChatroom
    let livestream: KickLivestream?
}

func getKickChannelInfo(channelName: String) async throws -> KickChannel {
    guard let url = URL(string: "https://kick.com/api/v1/channels/\(channelName)") else {
        throw "Invalid URL"
    }
    let (data, response) = try await httpGet(from: url)
    if !response.isSuccessful {
        throw "Not successful"
    }
    return try JSONDecoder().decode(KickChannel.self, from: data)
}

func getKickChannelInfo(channelName: String, onComplete: @escaping (KickChannel?) -> Void) {
    guard let url = URL(string: "https://kick.com/api/v1/channels/\(channelName)") else {
        onComplete(nil)
        return
    }
    let request = URLRequest(url: url)
    URLSession.shared.dataTask(with: request) { data, response, error in
        guard error == nil, let data, response?.http?.isSuccessful == true else {
            onComplete(nil)
            return
        }
        onComplete(try? JSONDecoder().decode(KickChannel.self, from: data))
    }
    .resume()
}



---
File: /Moblin/Platforms/Kick/KickPusher.swift
---

import Foundation

private struct Badge: Decodable {
    var type: String
}

private struct Identity: Decodable {
    var color: String
    var badges: [Badge]
}

private struct Sender: Decodable {
    var username: String
    var identity: Identity
}

private struct ChatMessage: Decodable {
    var content: String
    var sender: Sender

    func isModerator() -> Bool {
        return sender.identity.badges.contains(where: { $0.type == "moderator" })
    }

    func isSubscriber() -> Bool {
        return sender.identity.badges.contains(where: { $0.type == "subscriber" })
    }
}

private func decodeEvent(message: String) throws -> (String, String) {
    if let jsonData = message.data(using: String.Encoding.utf8) {
        let data = try JSONSerialization.jsonObject(
            with: jsonData,
            options: JSONSerialization.ReadingOptions.mutableContainers
        )
        if let jsonResult: NSDictionary = data as? NSDictionary {
            if let type: String = jsonResult["event"] as? String {
                if let data: String = jsonResult["data"] as? String {
                    return (type, data)
                }
            }
        }
    }
    throw "Failed to get message event type"
}

private func decodeChatMessage(data: String) throws -> ChatMessage {
    return try JSONDecoder().decode(
        ChatMessage.self,
        from: data.data(using: String.Encoding.utf8)!
    )
}

private var url =
    URL(
        string: "wss://ws-us2.pusher.com/app/32cbd69e4b950bf97679?protocol=7&client=js&version=7.6.0&flash=false"
    )!

protocol KickOusherDelegate: AnyObject {
    func kickPusherMakeErrorToast(title: String, subTitle: String?)
    func kickPusherAppendMessage(
        user: String,
        userColor: RgbColor?,
        segments: [ChatPostSegment],
        isSubscriber: Bool,
        isModerator: Bool
    )
}

final class KickPusher: NSObject {
    private var channelName: String
    private var channelId: String
    private var webSocket: WebSocketClient
    private var emotes: Emotes
    private let settings: SettingsStreamChat
    private var gotInfo = false
    private weak var delegate: (any KickOusherDelegate)?

    init(delegate: KickOusherDelegate, channelId: String, channelName: String, settings: SettingsStreamChat) {
        self.delegate = delegate
        self.channelId = channelId
        self.channelName = channelName
        self.settings = settings.clone()
        emotes = Emotes()
        webSocket = .init(url: url)
    }

    func start() {
        logger.debug("kick: Start")
        stopInternal()
        if channelName.isEmpty {
            connect()
        } else {
            getInfoAndConnect()
        }
    }

    private func getInfoAndConnect() {
        logger.debug("kick: Get info and connect")
        getKickChannelInfo(channelName: channelName) { [weak self] channelInfo in
            guard let self else {
                return
            }
            DispatchQueue.main.async {
                guard !self.gotInfo else {
                    return
                }
                guard let channelInfo else {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
                        self.getInfoAndConnect()
                    }
                    return
                }
                self.gotInfo = true
                self.channelId = String(channelInfo.chatroom.id)
                self.connect()
            }
        }
    }

    private func connect() {
        emotes.stop()
        emotes.start(
            platform: .kick,
            channelId: channelId,
            onError: handleError,
            onOk: handleOk,
            settings: settings
        )
        webSocket = .init(url: url)
        webSocket.delegate = self
        webSocket.start()
    }

    func stop() {
        logger.debug("kick: Stop")
        stopInternal()
    }

    func stopInternal() {
        emotes.stop()
        webSocket.stop()
        gotInfo = false
    }

    func isConnected() -> Bool {
        return webSocket.isConnected()
    }

    func hasEmotes() -> Bool {
        return emotes.isReady()
    }

    private func handleError(title: String, subTitle: String) {
        DispatchQueue.main.async {
            self.delegate?.kickPusherMakeErrorToast(title: title, subTitle: subTitle)
        }
    }

    private func handleOk(title: String) {
        DispatchQueue.main.async {
            self.delegate?.kickPusherMakeErrorToast(title: title, subTitle: nil)
        }
    }

    private func handleMessage(message: String) {
        do {
            let (type, data) = try decodeEvent(message: message)
            if type == "App\\Events\\ChatMessageEvent" {
                try handleChatMessageEvent(data: data)
            } else {
                logger.debug("kick: pusher: \(channelId): Unsupported type: \(type)")
            }
        } catch {
            logger
                .error("""
                kick: pusher: \(channelId): Failed to process \
                message \"\(message)\" with error \(error)
                """)
        }
    }

    private func handleChatMessageEvent(data: String) throws {
        let message = try decodeChatMessage(data: data)
        var segments: [ChatPostSegment] = []
        var id = 0
        for var segment in createKickSegments(message: message.content, id: &id) {
            if let text = segment.text {
                segments += emotes.createSegments(text: text, id: &id)
                segment.text = nil
            }
            if segment.text != nil || segment.url != nil {
                segments.append(segment)
            }
        }
        delegate?.kickPusherAppendMessage(
            user: message.sender.username,
            userColor: RgbColor.fromHex(string: message.sender.identity.color),
            segments: segments,
            isSubscriber: message.isSubscriber(),
            isModerator: message.isModerator()
        )
    }

    private func sendMessage(message: String) {
        logger.debug("kick: pusher: \(channelId): Sending \(message)")
        webSocket.send(string: message)
    }

    private func createKickSegments(message: String, id: inout Int) -> [ChatPostSegment] {
        var segments: [ChatPostSegment] = []
        var startIndex = message.startIndex
        for match in message[startIndex...].matches(of: /\[emote:(\d+):[^\]]+\]/) {
            let emoteId = match.output.1
            let textBeforeEmote = message[startIndex ..< match.range.lowerBound]
            let url = URL(string: "https://files.kick.com/emotes/\(emoteId)/fullsize")
            segments += makeChatPostTextSegments(text: String(textBeforeEmote), id: &id)
            segments.append(ChatPostSegment(id: id, url: url))
            id += 1
            startIndex = match.range.upperBound
        }
        if startIndex != message.endIndex {
            segments += makeChatPostTextSegments(text: String(message[startIndex...]), id: &id)
        }
        return segments
    }
}

extension KickPusher: WebSocketClientDelegate {
    func webSocketClientConnected(_: WebSocketClient) {
        logger.debug("kick: Connected")
        sendMessage(
            message: """
            {\"event\":\"pusher:subscribe\",
             \"data\":{\"auth\":\"\",\"channel\":\"chatrooms.\(channelId).v2\"}}
            """
        )
    }

    func webSocketClientDisconnected(_: WebSocketClient) {
        logger.debug("kick: Disconnected")
    }

    func webSocketClientReceiveMessage(_: WebSocketClient, string: String) {
        handleMessage(message: string)
    }
}



---
File: /Moblin/Platforms/Kick/KickViewers.swift
---

import Foundation

class KickViewers {
    private var task: Task<Void, Error>?
    var numberOfViewers: Int?

    func start(channelName: String) {
        task = Task.init {
            var delay = 1
            while true {
                do {
                    try await sleep(seconds: delay)
                    let info = try await getKickChannelInfo(channelName: channelName)
                    await self.setNumberOfViewers(value: info.livestream?.viewers)
                } catch {}
                if Task.isCancelled {
                    await self.setNumberOfViewers(value: nil)
                    break
                }
                delay = 30
            }
        }
    }

    private func setNumberOfViewers(value: Int?) async {
        await MainActor.run {
            self.numberOfViewers = value
        }
    }

    func stop() {
        task?.cancel()
        task = nil
    }
}



---
File: /Moblin/Platforms/Twitch/TwitchChatMoblin.swift
---

import Network
import SwiftUI
import TwitchChat

private func getEmotes(from message: ChatMessage) -> [ChatMessageEmote] {
    var emotes: [ChatMessageEmote] = []
    for emote in message.emotes {
        do {
            try emotes.append(ChatMessageEmote(url: emote.imageURL, range: emote.range))
        } catch {
            logger.warning("twitch: chat: Failed to get emote URL")
        }
    }
    return emotes
}

private class Badges {
    private var channelId: String = ""
    private var accessToken: String = ""
    private var urlSession = URLSession.shared
    private var badges: [String: TwitchApiChatBadgesVersion] = [:]
    private var tryFetchAgainTimer = SimpleTimer(queue: .main)

    func start(channelId: String, accessToken: String, urlSession: URLSession) {
        self.channelId = channelId
        self.accessToken = accessToken
        self.urlSession = urlSession
        guard !accessToken.isEmpty else {
            return
        }
        tryFetch()
    }

    func stop() {
        stopTryFetchAgainTimer()
    }

    func getUrl(badgeId: String) -> String? {
        return badges[badgeId]?.image_url_2x
    }

    func tryFetch() {
        startTryFetchAgainTimer()
        TwitchApi(accessToken, urlSession).getGlobalChatBadges { data in
            guard let data else {
                return
            }
            DispatchQueue.main.async {
                self.addBadges(badges: data)
                TwitchApi(self.accessToken, self.urlSession)
                    .getChannelChatBadges(broadcasterId: self.channelId) { data in
                        guard let data else {
                            return
                        }
                        DispatchQueue.main.async {
                            self.addBadges(badges: data)
                            self.stopTryFetchAgainTimer()
                        }
                    }
            }
        }
    }

    private func startTryFetchAgainTimer() {
        tryFetchAgainTimer.startSingleShot(timeout: 30) { [weak self] in
            self?.tryFetch()
        }
    }

    private func stopTryFetchAgainTimer() {
        tryFetchAgainTimer.stop()
    }

    private func addBadges(badges: [TwitchApiChatBadgesData]) {
        for badge in badges {
            for version in badge.versions {
                self.badges["\(badge.set_id)/\(version.id)"] = version
            }
        }
    }
}

private class Cheermotes {
    private var channelId: String = ""
    private var accessToken: String = ""
    private var urlSession: URLSession = .shared
    private var emotes: [String: [TwitchApiGetCheermotesDataTier]] = [:]
    private var tryFetchAgainTimer = SimpleTimer(queue: .main)

    func start(channelId: String, accessToken: String, urlSession: URLSession) {
        self.channelId = channelId
        self.accessToken = accessToken
        self.urlSession = urlSession
        guard !accessToken.isEmpty else {
            return
        }
        tryFetch()
    }

    func stop() {
        stopTryFetchAgainTimer()
    }

    func tryFetch() {
        startTryFetchAgainTimer()
        TwitchApi(accessToken, urlSession).getCheermotes(broadcasterId: channelId) { datas in
            guard let datas else {
                return
            }
            DispatchQueue.main.async {
                for data in datas {
                    self.emotes[data.prefix.lowercased()] = data.tiers
                }
                self.stopTryFetchAgainTimer()
            }
        }
    }

    private func startTryFetchAgainTimer() {
        tryFetchAgainTimer.startSingleShot(timeout: 30) { [weak self] in
            self?.tryFetch()
        }
    }

    private func stopTryFetchAgainTimer() {
        tryFetchAgainTimer.stop()
    }

    func getUrlAndBits(word: String) -> (URL, Int)? {
        let word = word.lowercased().trim()
        for (prefix, tiers) in emotes {
            guard let regex = try? Regex("\(prefix)(\\d+)", as: (Substring, Substring).self) else {
                continue
            }
            guard let match = try? regex.wholeMatch(in: word) else {
                continue
            }
            guard let bits = Int(match.output.1) else {
                continue
            }
            guard let tier = tiers.reversed().first(where: { bits >= $0.min_bits }) else {
                continue
            }
            guard let url = URL(string: tier.images.dark.static_.two) else {
                continue
            }
            return (url, bits)
        }
        return nil
    }
}

protocol TwitchChatMoblinDelegate: AnyObject {
    func twitchChatMoblinMakeErrorToast(title: String, subTitle: String?)
    func twitchChatMoblinAppendMessage(
        user: String?,
        userId: String?,
        userColor: RgbColor?,
        userBadges: [URL],
        segments: [ChatPostSegment],
        isAction: Bool,
        isSubscriber: Bool,
        isModerator: Bool,
        bits: String?,
        highlight: ChatHighlight?
    )
}

final class TwitchChatMoblin {
    private var webSocket: WebSocketClient
    private var emotes: Emotes
    private var badges: Badges
    private var cheermotes: Cheermotes
    private var channelName: String
    private weak var delegate: (any TwitchChatMoblinDelegate)?

    init(delegate: TwitchChatMoblinDelegate) {
        self.delegate = delegate
        channelName = ""
        emotes = Emotes()
        badges = Badges()
        cheermotes = Cheermotes()
        webSocket = .init(url: URL(string: "wss://irc-ws.chat.twitch.tv")!)
    }

    func start(
        channelName: String,
        channelId: String,
        settings: SettingsStreamChat,
        accessToken: String,
        httpProxy: HttpProxy?,
        urlSession: URLSession
    ) {
        self.channelName = channelName
        logger.debug("twitch: chat: Start")
        stopInternal()
        emotes.start(
            platform: .twitch,
            channelId: channelId,
            onError: handleError,
            onOk: handleOk,
            settings: settings
        )
        badges.start(channelId: channelId, accessToken: accessToken, urlSession: urlSession)
        cheermotes.start(channelId: channelId, accessToken: accessToken, urlSession: urlSession)
        webSocket = .init(url: URL(string: "wss://irc-ws.chat.twitch.tv")!, httpProxy: httpProxy)
        webSocket.delegate = self
        webSocket.start()
    }

    func stop() {
        logger.debug("twitch: chat: Stop")
        stopInternal()
    }

    func stopInternal() {
        emotes.stop()
        badges.stop()
        cheermotes.stop()
        webSocket.stop()
    }

    private func handleMessage(message: String) throws {
        let message = try Message(string: message)
        if let chatMessage = ChatMessage(message) {
            try handleChatMessage(message: chatMessage)
        } else if message.command == .ping {
            webSocket.send(string: "PONG \(message.parameters.joined(separator: " "))")
        }
    }

    private func handleChatMessage(message: ChatMessage) throws {
        let emotes = getEmotes(from: message)
        var badgeUrls: [URL] = []
        for badge in message.badges {
            if let badgeUrl = badges.getUrl(badgeId: badge), let badgeUrl = URL(string: badgeUrl) {
                badgeUrls.append(badgeUrl)
            }
        }
        let text: String
        let isAction = message.isAction()
        if isAction {
            text = String(message.text.dropFirst(7))
        } else {
            text = message.text
        }
        let segments = createSegments(
            text: text,
            emotes: emotes,
            emotesManager: self.emotes,
            bits: message.bits
        )
        delegate?.twitchChatMoblinAppendMessage(
            user: message.sender,
            userId: message.userId,
            userColor: RgbColor.fromHex(string: message.senderColor ?? ""),
            userBadges: badgeUrls,
            segments: segments,
            isAction: isAction,
            isSubscriber: message.subscriber,
            isModerator: message.moderator,
            bits: message.bits,
            highlight: createHighlight(message: message)
        )
    }

    func createSegmentsNoTwitchEmotes(text: String, bits: String?) -> [ChatPostSegment] {
        return createSegments(text: text, emotes: [], emotesManager: emotes, bits: bits)
    }

    private func createHighlight(message: ChatMessage) -> ChatHighlight? {
        if message.announcement {
            return .init(
                kind: .other,
                color: .green,
                image: "horn.blast",
                title: String(localized: "Announcement")
            )
        } else if message.firstMessage {
            return .init(
                kind: .firstMessage,
                color: .yellow,
                image: "bubble.left",
                title: String(localized: "First time chatter")
            )
        } else {
            return nil
        }
    }

    func isConnected() -> Bool {
        return webSocket.isConnected()
    }

    func hasEmotes() -> Bool {
        return emotes.isReady()
    }

    private func handleError(title: String, subTitle: String) {
        DispatchQueue.main.async {
            self.delegate?.twitchChatMoblinMakeErrorToast(title: title, subTitle: subTitle)
        }
    }

    private func handleOk(title: String) {
        DispatchQueue.main.async {
            self.delegate?.twitchChatMoblinMakeErrorToast(title: title, subTitle: nil)
        }
    }

    private func createTwitchSegments(text: String,
                                      emotes: [ChatMessageEmote],
                                      id: inout Int) -> [ChatPostSegment]
    {
        var segments: [ChatPostSegment] = []
        let unicodeText = text.unicodeScalars
        var startIndex = unicodeText.startIndex
        for emote in emotes.sorted(by: { lhs, rhs in
            lhs.range.lowerBound < rhs.range.lowerBound
        }) {
            if !(emote.range.lowerBound < unicodeText.count) {
                logger
                    .warning(
                        """
                        twitch: chat: Emote lower bound \(emote.range.lowerBound) after \
                        message end \(unicodeText.count) '\(unicodeText)'
                        """
                    )
                break
            }
            if !(emote.range.upperBound < unicodeText.count) {
                logger
                    .warning(
                        """
                        twitch: chat: Emote upper bound \(emote.range.upperBound) after \
                        message end \(unicodeText.count) '\(unicodeText)'
                        """
                    )
                break
            }
            var text: String?
            if emote.range.lowerBound > 0 {
                let endIndex = unicodeText.index(
                    unicodeText.startIndex,
                    offsetBy: emote.range.lowerBound - 1
                )
                if startIndex < endIndex {
                    text = String(unicodeText[startIndex ... endIndex])
                }
            }
            if let text {
                segments += makeChatPostTextSegments(text: text, id: &id)
            }
            segments.append(ChatPostSegment(id: id, url: emote.url))
            id += 1
            segments.append(ChatPostSegment(id: id, text: ""))
            id += 1
            startIndex = unicodeText.index(
                unicodeText.startIndex,
                offsetBy: emote.range.upperBound + 1
            )
        }
        if startIndex < unicodeText.endIndex {
            for word in String(unicodeText[startIndex...]).split(separator: " ") {
                segments.append(ChatPostSegment(id: id, text: "\(word) "))
                id += 1
            }
        }
        return segments
    }

    private func createSegments(text: String,
                                emotes: [ChatMessageEmote],
                                emotesManager: Emotes,
                                bits: String?) -> [ChatPostSegment]
    {
        var segments: [ChatPostSegment] = []
        var id = 0
        for var segment in createTwitchSegments(text: text, emotes: emotes, id: &id) {
            if let text = segment.text {
                segments += emotesManager.createSegments(text: text, id: &id)
                segment.text = nil
            }
            if segment.text != nil || segment.url != nil {
                segments.append(segment)
            }
        }
        if bits != nil {
            segments = replaceCheermotes(segments: segments)
        }
        return segments
    }

    private func replaceCheermotes(segments: [ChatPostSegment]) -> [ChatPostSegment] {
        var newSegments: [ChatPostSegment] = []
        guard var id = segments.last?.id else {
            return newSegments
        }
        for segment in segments {
            guard let text = segment.text else {
                newSegments.append(segment)
                continue
            }
            guard let (url, bits) = cheermotes.getUrlAndBits(word: text) else {
                newSegments.append(segment)
                continue
            }
            id += 1
            newSegments.append(.init(id: id, url: url))
            id += 1
            newSegments.append(.init(id: id, text: "\(bits) "))
        }
        return newSegments
    }
}

extension ChatMessage {
    func isAction() -> Bool {
        return text.starts(with: "\u{01}ACTION")
    }
}

extension TwitchChatMoblin: WebSocketClientDelegate {
    func webSocketClientConnected(_ webSocket: WebSocketClient) {
        logger.debug("twitch: chat: Connected")
        webSocket.send(string: "CAP REQ :twitch.tv/membership")
        webSocket.send(string: "CAP REQ :twitch.tv/tags")
        webSocket.send(string: "CAP REQ :twitch.tv/commands")
        webSocket.send(string: "PASS oauth:SCHMOOPIIE")
        webSocket.send(string: "NICK justinfan67420")
        webSocket.send(string: "JOIN #\(channelName)")
    }

    func webSocketClientDisconnected(_: WebSocketClient) {
        logger.debug("twitch: chat: Disconnected")
    }

    func webSocketClientReceiveMessage(_: WebSocketClient, string: String) {
        for line in string.split(whereSeparator: { $0.isNewline }) {
            try? handleMessage(message: String(line))
        }
    }
}



---
File: /Moblin/Platforms/YouTube/YouTubeLiveChat.swift
---

import Foundation

private let userAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:124.0) Gecko/20100101 Firefox/124.0"
private let minimumPollDelayMs = 200
private let maximumPollDelayMs = 3000

private func createPaidMessageHighlight(chatDescription: ChatDescription) -> ChatHighlight {
    var amount = ""
    if let text = chatDescription.purchaseAmountText?.simpleText {
        amount = ", \(text)"
    }
    return ChatHighlight(
        kind: .other,
        color: .orange,
        image: "message",
        title: String(localized: "Super Chat\(amount)")
    )
}

private func createPaidStickerHighlight(chatDescription: ChatDescription) -> ChatHighlight {
    var amount = ""
    if let text = chatDescription.purchaseAmountText?.simpleText {
        amount = ", \(text)"
    }
    return ChatHighlight(
        kind: .other,
        color: .green,
        image: "doc.plaintext",
        title: String(localized: "Super Sticker\(amount)")
    )
}

private func createMemberHighlight() -> ChatHighlight {
    return ChatHighlight(kind: .other, color: .blue, image: "medal", title: String(localized: "Member"))
}

private struct InvalidationContinuationData: Codable {
    let continuation: String
}

private struct Continuations: Codable {
    let invalidationContinuationData: InvalidationContinuationData
}

private struct Thumbnail: Codable {
    let url: String
}

private struct Image: Codable {
    let thumbnails: [Thumbnail]
}

private struct Emoji: Codable {
    let image: Image
}

private struct Run: Codable {
    let text: String?
    let emoji: Emoji?
}

private struct Message: Codable {
    let runs: [Run]
}

private struct Author: Codable {
    let simpleText: String
}

private struct Amount: Codable {
    let simpleText: String
}

private struct ChatDescription: Codable {
    let authorName: Author
    let message: Message?
    let purchaseAmountText: Amount?
    let headerSubtext: Message?
}

private struct AddChatItemActionItem: Codable {
    let liveChatTextMessageRenderer: ChatDescription?
    let liveChatPaidMessageRenderer: ChatDescription?
    let liveChatPaidStickerRenderer: ChatDescription?
    let liveChatMembershipItemRenderer: ChatDescription?
    // let liveChatSponsorshipsGiftPurchaseAnnouncementRenderer: ?
}

private struct AddChatItemAction: Codable {
    let item: AddChatItemActionItem
}

private struct Action: Codable {
    let addChatItemAction: AddChatItemAction?
}

private struct LiveChatContinuation: Codable {
    let continuations: [Continuations]
    let actions: [Action]?
}

private struct ContinuationContents: Codable {
    let liveChatContinuation: LiveChatContinuation
}

private struct GetLiveChat: Codable {
    let continuationContents: ContinuationContents
}

final class YouTubeLiveChat: NSObject {
    private var model: Model
    private var videoId: String
    private var task: Task<Void, Error>?
    private var emotes: Emotes
    private var settings: SettingsStreamChat
    private var connected: Bool = false
    private var continuation: String = ""
    private var delay = 2000

    init(model: Model, videoId: String, settings: SettingsStreamChat) {
        self.model = model
        self.videoId = videoId
        self.settings = settings.clone()
        emotes = Emotes()
    }

    func start() {
        emotes.start(
            platform: .youtube,
            channelId: videoId,
            onError: handleError,
            onOk: handleOk,
            settings: settings
        )
        task = Task.init {
            while true {
                do {
                    try await getInitialContinuation()
                    connected = true
                    try await readMessages()
                } catch {}
                connected = false
                if Task.isCancelled {
                    break
                }
                try await sleep(seconds: 5)
            }
        }
    }

    func stop() {
        emotes.stop()
        task?.cancel()
        task = nil
        connected = false
    }

    func isConnected() -> Bool {
        return connected
    }

    func hasEmotes() -> Bool {
        return emotes.isReady()
    }

    private func handleError(title: String, subTitle: String) {
        DispatchQueue.main.async {
            self.model.makeErrorToast(title: title, subTitle: subTitle)
        }
    }

    private func handleOk(title: String) {
        DispatchQueue.main.async {
            self.model.makeToast(title: title)
        }
    }

    private func makeLiveChatUrl() -> URL? {
        return URL(string: "https://www.youtube.com/live_chat?is_popout=1&v=\(videoId)")
    }

    private func makeGetLiveChatUrl() -> URL? {
        return URL(string: "https://www.youtube.com/youtubei/v1/live_chat/get_live_chat")
    }

    private func getInitialContinuation() async throws {
        guard let url = makeLiveChatUrl() else {
            throw "Failed to create URL"
        }
        let (data, response) = try await fetch(from: url)
        if !response.isSuccessful {
            throw "Unsuccessful HTTP response"
        }
        guard let body = String(bytes: data, encoding: .utf8) else {
            throw "Not UTF-8 body"
        }
        let re_continuation = /"continuation":"([^"]+)"/
        guard let match = try re_continuation.firstMatch(in: body) else {
            throw "No continuation"
        }
        continuation = String(match.1)
    }

    private func readMessages() async throws {
        guard let url = makeGetLiveChatUrl() else {
            throw "Failed to create URL"
        }
        while true {
            let (data, response) = try await upload(from: url, data: makeGetLiveChatBody())
            if !response.isSuccessful {
                throw "Unsuccessful HTTP response"
            }
            var numberOfMessages = 0
            let getLiveChat = try JSONDecoder().decode(GetLiveChat.self, from: data)
            if let actions = getLiveChat.continuationContents.liveChatContinuation.actions {
                for action in actions {
                    guard let item = action.addChatItemAction?.item else {
                        continue
                    }
                    if let chatDescription = item.liveChatTextMessageRenderer {
                        numberOfMessages += await handleChatDescription(
                            chatDescription: chatDescription,
                            highlight: nil
                        )
                    }
                    if let chatDescription = item.liveChatPaidMessageRenderer {
                        numberOfMessages += await handleChatDescription(
                            chatDescription: chatDescription,
                            highlight: createPaidMessageHighlight(chatDescription: chatDescription)
                        )
                    }
                    if let chatDescription = item.liveChatPaidStickerRenderer {
                        numberOfMessages += await handleChatDescription(
                            chatDescription: chatDescription,
                            highlight: createPaidStickerHighlight(chatDescription: chatDescription)
                        )
                    }
                    if let chatDescription = item.liveChatMembershipItemRenderer {
                        numberOfMessages += await handleChatDescription(
                            chatDescription: chatDescription,
                            highlight: createMemberHighlight()
                        )
                    }
                }
            }
            try updateContinuation(getLiveChat: getLiveChat)
            updateDelayMs(numberOfMessages: numberOfMessages)
            try await sleep(milliSeconds: delay)
        }
    }

    private func updateDelayMs(numberOfMessages: Int) {
        if numberOfMessages > 0 {
            delay = delay * 5 / numberOfMessages
        } else {
            delay = maximumPollDelayMs
        }

        if delay > maximumPollDelayMs {
            delay = maximumPollDelayMs
        }

        if delay < minimumPollDelayMs {
            delay = minimumPollDelayMs
        }
    }

    private func handleChatDescription(chatDescription: ChatDescription,
                                       highlight: ChatHighlight?) async -> Int
    {
        var id = 0
        var segments: [ChatPostSegment] = []
        if let headerSubtext = chatDescription.headerSubtext {
            for run in headerSubtext.runs {
                if let text = run.text {
                    segments += createSegments(message: text, id: &id)
                }
                if let emojiUrl = run.emoji?.image.thumbnails.first?.url {
                    segments.append(.init(id: id, url: URL(string: emojiUrl)))
                    id += 1
                }
            }
        }
        if let message = chatDescription.message {
            for run in message.runs {
                if let text = run.text {
                    segments += createSegments(message: text, id: &id)
                }
                if let emojiUrl = run.emoji?.image.thumbnails.first?.url {
                    segments.append(.init(id: id, url: URL(string: emojiUrl)))
                    id += 1
                }
            }
        }
        guard !segments.isEmpty || highlight != nil else {
            return 0
        }
        let nonMutSegments = segments
        await MainActor.run {
            model.appendChatMessage(platform: .youTube,
                                    user: chatDescription.authorName.simpleText,
                                    userId: nil,
                                    userColor: nil,
                                    userBadges: [],
                                    segments: nonMutSegments,
                                    timestamp: model.digitalClock,
                                    timestampTime: .now,
                                    isAction: false,
                                    isSubscriber: false,
                                    isModerator: false,
                                    bits: nil,
                                    highlight: highlight, live: true)
        }
        return 1
    }

    private func updateContinuation(getLiveChat: GetLiveChat) throws {
        guard let continuation = getLiveChat.continuationContents.liveChatContinuation.continuations.first
        else {
            throw "Continuation missing"
        }
        self.continuation = continuation.invalidationContinuationData.continuation
    }

    private func makeGetLiveChatBody() -> Data {
        return """
        {
            "context": {
                "client": {
                    "clientName": "WEB",
                    "clientVersion": "2.20210128.02.00"
                }
            },
            "continuation": "\(continuation)"
        }
        """.utf8Data
    }

    private func createSegments(message: String, id: inout Int) -> [ChatPostSegment] {
        var segments: [ChatPostSegment] = []
        for var segment in makeChatPostTextSegments(text: message, id: &id) {
            if let text = segment.text {
                segments += emotes.createSegments(text: text, id: &id)
                segment.text = nil
            }
            if segment.text != nil || segment.url != nil {
                segments.append(segment)
            }
        }
        return segments
    }

    private func fetch(from: URL) async throws -> (Data, HTTPURLResponse) {
        var request = URLRequest(url: from)
        request.setValue(userAgent, forHTTPHeaderField: "User-Agent")
        let (data, response) = try await URLSession.shared.data(for: request)
        if let response = response.http {
            return (data, response)
        } else {
            throw "Not an HTTP response"
        }
    }

    private func upload(from: URL, data: Data) async throws -> (Data, HTTPURLResponse) {
        var request = URLRequest(url: from)
        request.httpMethod = "POST"
        request.setValue(userAgent, forHTTPHeaderField: "User-Agent")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        let (data, response) = try await URLSession.shared.upload(for: request, from: data)
        if let response = response.http {
            return (data, response)
        } else {
            throw "Not an HTTP response"
        }
    }
}



---
File: /Moblin/Various/AlertMediaStorage.swift
---

import Foundation

class AlertMediaStorage {
    private var fileManager: FileManager
    private var mediasUrl: URL

    init() {
        fileManager = FileManager.default
        let homeUrl = fileManager.urls(for: .documentDirectory, in: .userDomainMask)
            .first!
        mediasUrl = homeUrl.appendingPathComponent("Alerts")
        do {
            try fileManager.createDirectory(
                at: mediasUrl,
                withIntermediateDirectories: true,
                attributes: nil
            )
        } catch {
            logger.error("alert-media-storage: Error creating images directory: \(error)")
        }
    }

    func makePath(id: UUID) -> URL {
        return mediasUrl.appendingPathComponent(id.uuidString)
    }

    func ids() -> [UUID] {
        do {
            var ids: [UUID] = []
            for file in try fileManager.contentsOfDirectory(atPath: mediasUrl.path) {
                if let id = UUID(uuidString: file) {
                    ids.append(id)
                }
            }
            return ids
        } catch {}
        return []
    }

    func add(id: UUID, url: URL) {
        do {
            let path = makePath(id: id)
            try? fileManager.removeItem(at: path)
            try fileManager.moveItem(at: url, to: path)
        } catch {
            logger.info("alert-media-storage: Move failed with error \(error)")
        }
    }

    func remove(id: UUID) {
        do {
            try fileManager.removeItem(at: makePath(id: id))
        } catch {
            logger.error("alert-media-storage: Remove failed with error \(error)")
        }
    }

    func tryRead(id: UUID) -> Data? {
        return try? Data(contentsOf: makePath(id: id))
    }
}



---
File: /Moblin/Various/ChatBotCommand.swift
---

import Collections

struct ChatBotMessage {
    let platform: Platform
    let user: String?
    let isModerator: Bool
    let isSubscriber: Bool
    let userId: String?
    let segments: [ChatPostSegment]
}

class ChatBotCommand {
    let message: ChatBotMessage
    private var parts: Deque<String> = []

    init?(message: ChatBotMessage) {
        self.message = message
        guard message.segments.count > 1 else {
            return nil
        }
        for segment in message.segments.suffix(from: 1) {
            if let text = segment.text {
                parts.append(text.trim())
            }
        }
    }

    func popFirst() -> String? {
        return parts.popFirst()
    }

    func rest() -> String {
        return parts.joined(separator: " ")
    }

    func user() -> String? {
        return message.user
    }
}



---
File: /Moblin/Various/ChatTextToSpeech.swift
---

import AVFAudio
import Collections
import NaturalLanguage

private let textToSpeechDispatchQueue = DispatchQueue(label: "com.eerimoq.textToSpeech", qos: .utility)

private struct TextToSpeechMessage {
    let user: String
    let message: String
    let isRedemption: Bool
}

private let saysByLanguage = [
    "en": "says",
    "sv": "säger",
    "no": "sier",
    "es": "dice",
    "de": "sagt",
    "fr": "dit",
    "pl": "mówi",
    "vi": "nói",
    "nl": "zegt",
    "zh": "说",
    "ko": "라고",
    "ru": "говорит",
    "uk": "каже",
]

class ChatTextToSpeech: NSObject {
    private var rate: Float = 0.4
    private var volume: Float = 0.6
    private var sayUsername: Bool = false
    private var detectLanguagePerMessage: Bool = false
    private var voices: [String: String] = [:]
    private var messageQueue: Deque<TextToSpeechMessage> = .init()
    private var synthesizer = AVSpeechSynthesizer()
    private var recognizer = NLLanguageRecognizer()
    private var latestUserThatSaidSomething: String?
    private var sayLatestUserThatSaidSomethingAgain = ContinuousClock.now
    private var filterEnabled: Bool = true
    private var filterMentionsEnabled: Bool = true
    private var streamerMentions: [String] = []
    private var running = true

    private func isFilteredOut(message: String) -> Bool {
        if isFilteredOutFilter(message: message) {
            return true
        }
        if isFilteredOutFilterMentions(message: message) {
            return true
        }
        return false
    }

    private func isFilteredOutFilter(message: String) -> Bool {
        if !filterEnabled {
            return false
        }
        let probability = recognizer.languageHypotheses(withMaximum: 1).first?.value ?? 0.0
        if probability < 0.7 && message.count > 30 {
            return true
        }
        if message.hasPrefix("!") {
            return true
        }
        if message.contains("https") {
            return true
        }
        return false
    }

    private func isFilteredOutFilterMentions(message: String) -> Bool {
        if !filterMentionsEnabled {
            return false
        }
        if message.starts(with: "@") || message.contains(" @") {
            for streamerMention in streamerMentions {
                if let range = message.range(of: streamerMention) {
                    if isStreamerMention(
                        message: message,
                        mentionLowerBound: range.lowerBound,
                        mentionUpperBound: range.upperBound
                    ) {
                        return false
                    }
                }
            }
            return true
        }
        return false
    }

    private func isStreamerMention(
        message: String,
        mentionLowerBound: String.Index,
        mentionUpperBound: String.Index
    ) -> Bool {
        // There is always a space at the end of the message, so this should never happen.
        guard mentionUpperBound < message.endIndex else {
            return false
        }
        if mentionLowerBound > message.startIndex {
            if message[message.index(before: mentionLowerBound)] != " " {
                return false
            }
        }
        if message[mentionUpperBound] != " " {
            return false
        }
        return true
    }

    private func getSays(_ language: String) -> String {
        return saysByLanguage[language] ?? ""
    }

    private func getVoice(message: String) -> (AVSpeechSynthesisVoice?, String)? {
        recognizer.reset()
        recognizer.processString(message)
        guard !isFilteredOut(message: message) else {
            return nil
        }
        var language = recognizer.dominantLanguage?.rawValue
        if !detectLanguagePerMessage || language == nil {
            language = Locale.current.language.languageCode?.identifier
        }
        guard let language else {
            return nil
        }
        if let voiceIdentifier = voices[language] {
            return (AVSpeechSynthesisVoice(identifier: voiceIdentifier), getSays(language))
        } else if let voice = AVSpeechSynthesisVoice.speechVoices()
            .filter({ $0.language.starts(with: language) }).first
        {
            return (AVSpeechSynthesisVoice(identifier: voice.identifier), getSays(language))
        }
        return nil
    }

    private func trySayNextMessage() {
        guard !synthesizer.isSpeaking else {
            return
        }
        guard let message = messageQueue.popFirst() else {
            return
        }
        guard let (voice, says) = getVoice(message: message.message) else {
            return
        }
        guard let voice else {
            return
        }
        let text: String
        let now = ContinuousClock.now
        if message.isRedemption {
            text = "\(message.user) \(message.message)"
        } else if !shouldSayUser(user: message.user, now: now) || !sayUsername {
            text = message.message
        } else {
            text = String(localized: "\(message.user) \(says): \(message.message)")
        }
        let utterance = AVSpeechUtterance(string: text)
        utterance.rate = rate
        utterance.pitchMultiplier = 0.8
        utterance.preUtteranceDelay = 0.05
        utterance.volume = volume
        utterance.voice = voice
        synthesizer.speak(utterance)
        latestUserThatSaidSomething = message.user
        sayLatestUserThatSaidSomethingAgain = now.advanced(by: .seconds(30))
    }

    private func shouldSayUser(user: String, now: ContinuousClock.Instant) -> Bool {
        if user != latestUserThatSaidSomething {
            return true
        }
        if now > sayLatestUserThatSaidSomethingAgain {
            return true
        }
        return false
    }

    func say(user: String, message: String, isRedemption: Bool) {
        textToSpeechDispatchQueue.async {
            guard self.running else {
                return
            }
            self.messageQueue.append(.init(user: user, message: message, isRedemption: isRedemption))
            self.trySayNextMessage()
        }
    }

    func setRate(rate: Float) {
        textToSpeechDispatchQueue.async {
            self.rate = rate
        }
    }

    func setVolume(volume: Float) {
        textToSpeechDispatchQueue.async {
            self.volume = volume
        }
    }

    func setVoices(voices: [String: String]) {
        textToSpeechDispatchQueue.async {
            self.voices = voices
        }
    }

    func setSayUsername(value: Bool) {
        textToSpeechDispatchQueue.async {
            self.sayUsername = value
        }
    }

    func setFilter(value: Bool) {
        textToSpeechDispatchQueue.async {
            self.filterEnabled = value
        }
    }

    func setFilterMentions(value: Bool) {
        textToSpeechDispatchQueue.async {
            self.filterMentionsEnabled = value
        }
    }

    func setStreamerMentions(streamerMentions: [String]) {
        textToSpeechDispatchQueue.async {
            self.streamerMentions = streamerMentions
        }
    }

    func setDetectLanguagePerMessage(value: Bool) {
        textToSpeechDispatchQueue.async {
            self.detectLanguagePerMessage = value
        }
    }

    func reset(running: Bool) {
        textToSpeechDispatchQueue.async {
            self.running = running
            self.synthesizer.stopSpeaking(at: .word)
            self.latestUserThatSaidSomething = nil
            self.messageQueue.removeAll()
            self.synthesizer = AVSpeechSynthesizer()
            self.synthesizer.delegate = self
            self.recognizer = NLLanguageRecognizer()
        }
    }

    func skipCurrentMessage() {
        textToSpeechDispatchQueue.async {
            self.synthesizer.stopSpeaking(at: .word)
            self.trySayNextMessage()
        }
    }
}

extension ChatTextToSpeech: AVSpeechSynthesizerDelegate {
    func speechSynthesizer(_: AVSpeechSynthesizer, didFinish _: AVSpeechUtterance) {
        textToSpeechDispatchQueue.async {
            self.trySayNextMessage()
        }
    }
}



---
File: /Moblin/Various/WebSocetClient.swift
---

//
//  WebSocetClient.swift
//  Moblin
//
//  Created by Erik Moqvist on 2024-06-05.
//

import Foundation



---
File: /Moblin/Various/WebSocketClient.swift
---

import Network
import NWWebSocket
import SwiftUI
import TwitchChat

private let shortestDelayMs = 500
private let longestDelayMs = 10000

protocol WebSocketClientDelegate: AnyObject {
    func webSocketClientConnected(_ webSocket: WebSocketClient)
    func webSocketClientDisconnected(_ webSocket: WebSocketClient)
    func webSocketClientReceiveMessage(_ webSocket: WebSocketClient, string: String)
}

final class WebSocketClient {
    private var webSocket: NWWebSocket
    private var connectTimer = SimpleTimer(queue: .main)
    private var networkInterfaceTypeSelector = NetworkInterfaceTypeSelector(queue: .main)
    private var pingTimer = SimpleTimer(queue: .main)
    private var pongReceived = true
    var delegate: (any WebSocketClientDelegate)?
    private let url: URL
    private let loopback: Bool
    private var connected = false
    private var connectDelayMs = shortestDelayMs
    private let proxyConfig: NWWebSocketProxyConfig?

    init(url: URL, httpProxy: HttpProxy? = nil, loopback: Bool = false) {
        self.url = url
        self.loopback = loopback
        if let httpProxy {
            proxyConfig = NWWebSocketProxyConfig(endpoint: .hostPort(
                host: .init(httpProxy.host),
                port: .init(integerLiteral: httpProxy.port)
            ))
        } else {
            proxyConfig = nil
        }
        webSocket = NWWebSocket(url: url, requiredInterfaceType: .cellular)
    }

    func start() {
        startInternal()
    }

    func stop() {
        stopInternal()
    }

    func isConnected() -> Bool {
        return connected
    }

    func send(string: String) {
        webSocket.send(string: string)
    }

    private func startInternal() {
        stopInternal()
        if var interfaceType = networkInterfaceTypeSelector.getNextType() {
            if loopback {
                interfaceType = .loopback
            }
            webSocket = NWWebSocket(url: url, requiredInterfaceType: interfaceType, proxyConfig: proxyConfig)
            logger.debug("websocket: Connecting to \(url) over \(interfaceType)")
            webSocket.delegate = self
            webSocket.connect()
            startPingTimer()
        } else {
            connectDelayMs = shortestDelayMs
            startConnectTimer()
        }
    }

    private func stopInternal() {
        connected = false
        webSocket.disconnect()
        webSocket = .init(url: url, requiredInterfaceType: .cellular)
        stopConnectTimer()
        stopPingTimer()
    }

    private func startConnectTimer() {
        connected = false
        connectTimer.startSingleShot(timeout: Double(connectDelayMs) / 1000) { [weak self] in
            self?.startInternal()
        }
        connectDelayMs *= 2
        if connectDelayMs > longestDelayMs {
            connectDelayMs = longestDelayMs
        }
    }

    private func stopConnectTimer() {
        connectTimer.stop()
    }

    private func startPingTimer() {
        pongReceived = true
        pingTimer.startPeriodic(interval: 10, initial: 0) { [weak self] in
            guard let self else {
                return
            }
            if self.pongReceived {
                self.pongReceived = false
                self.webSocket.ping()
            } else {
                self.startInternal()
                self.delegate?.webSocketClientDisconnected(self)
            }
        }
    }

    private func stopPingTimer() {
        pingTimer.stop()
    }
}

extension WebSocketClient: WebSocketConnectionDelegate {
    func webSocketDidConnect(connection _: WebSocketConnection) {
        logger.debug("websocket: Connected")
        connectDelayMs = shortestDelayMs
        stopConnectTimer()
        connected = true
        delegate?.webSocketClientConnected(self)
    }

    func webSocketDidDisconnect(connection _: WebSocketConnection,
                                closeCode _: NWProtocolWebSocket.CloseCode, reason _: Data?)
    {
        logger.debug("websocket: Disconnected")
        stopInternal()
        startConnectTimer()
        delegate?.webSocketClientDisconnected(self)
    }

    func webSocketViabilityDidChange(connection _: WebSocketConnection, isViable: Bool) {
        logger.debug("websocket: Viability changed to \(isViable)")
        guard !isViable else {
            return
        }
        stopInternal()
        startConnectTimer()
        delegate?.webSocketClientDisconnected(self)
    }

    func webSocketDidAttemptBetterPathMigration(result _: Result<WebSocketConnection, NWError>) {
        logger.debug("websocket: Better path migration")
    }

    func webSocketDidReceiveError(connection _: WebSocketConnection, error: NWError) {
        logger.debug("websocket: Error \(error.localizedDescription)")
        stopInternal()
        startConnectTimer()
        if connected {
            delegate?.webSocketClientDisconnected(self)
        }
    }

    func webSocketDidReceivePong(connection _: WebSocketConnection) {
        pongReceived = true
    }

    func webSocketDidReceiveMessage(connection _: WebSocketConnection, string: String) {
        delegate?.webSocketClientReceiveMessage(self, string: string)
    }

    func webSocketDidReceiveMessage(connection _: WebSocketConnection, data _: Data) {}
}



---
File: /Moblin/View/ControlBar/QuickButton/QuickButtonChatView.swift
---

import Foundation
import SDWebImageSwiftUI
import SwiftUI
import WrappingHStack

private struct HighlightMessageView: View {
    let image: String
    let name: String

    var body: some View {
        WrappingHStack(
            alignment: .leading,
            horizontalSpacing: 0,
            verticalSpacing: 0,
            fitContentWidth: true
        ) {
            Image(systemName: image)
            Text(" ")
            Text(name)
        }
        .padding([.leading], 5)
    }
}

private struct LineView: View {
    var post: ChatPost
    var chat: SettingsChat

    private func usernameColor() -> Color {
        if let color = post.userColor {
            return color.color()
        } else {
            return chat.usernameColor.color()
        }
    }

    var body: some View {
        let usernameColor = usernameColor()
        WrappingHStack(
            alignment: .leading,
            horizontalSpacing: 0,
            verticalSpacing: 0,
            fitContentWidth: true
        ) {
            if chat.timestampColorEnabled {
                Text("\(post.timestamp) ")
                    .foregroundColor(.gray)
            }
            if chat.badges! {
                ForEach(post.userBadges, id: \.self) { url in
                    CacheAsyncImage(url: url) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                    } placeholder: {
                        EmptyView()
                    }
                    .padding(2)
                    .frame(height: CGFloat(chat.fontSize * 1.4))
                }
            }
            Text(post.user!)
                .foregroundColor(usernameColor)
                .lineLimit(1)
                .padding([.trailing], 0)
                .bold()
            if post.isRedemption() {
                Text(" ")
            } else {
                Text(": ")
            }
            ForEach(post.segments, id: \.id) { segment in
                if let text = segment.text {
                    Text(text)
                        .italic(post.isAction)
                }
                if let url = segment.url {
                    if chat.animatedEmotes {
                        WebImage(url: url)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(height: 25)
                    } else {
                        CacheAsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fit)
                        } placeholder: {
                            EmptyView()
                        }
                        .frame(height: 25)
                    }
                    Text(" ")
                }
            }
        }
        .padding([.leading], 5)
    }
}

struct ChildSizeReader<Content: View>: View {
    // periphery:ignore
    @Binding var size: CGSize
    let content: () -> Content

    var body: some View {
        content()
            .background(
                GeometryReader { proxy in
                    Color.clear.preference(key: SizePreferenceKey.self, value: proxy.size)
                }
            )
            .onPreferenceChange(SizePreferenceKey.self) { preferences in
                self.size = preferences
            }
    }
}

struct SizePreferenceKey: PreferenceKey {
    static var defaultValue: CGSize = .zero

    static func reduce(value _: inout CGSize, nextValue: () -> CGSize) {
        _ = nextValue()
    }
}

private var previousOffset = 0.0

private struct MessagesView: View {
    @EnvironmentObject var model: Model
    private let spaceName = "scroll"
    @State var wholeSize: CGSize = .zero
    @State var scrollViewSize: CGSize = .zero

    var body: some View {
        GeometryReader { metrics in
            ChildSizeReader(size: $wholeSize) {
                ScrollView {
                    ChildSizeReader(size: $scrollViewSize) {
                        VStack {
                            LazyVStack(alignment: .leading, spacing: 1) {
                                ForEach(model.interactiveChatPosts) { post in
                                    if post.user != nil {
                                        if let highlight = post.highlight {
                                            HStack(spacing: 0) {
                                                Rectangle()
                                                    .frame(width: 3)
                                                    .foregroundColor(highlight.color)
                                                VStack(alignment: .leading, spacing: 1) {
                                                    HighlightMessageView(
                                                        image: highlight.image,
                                                        name: highlight.title
                                                    )
                                                    LineView(
                                                        post: post,
                                                        chat: model.database.chat
                                                    )
                                                }
                                            }
                                            .rotationEffect(Angle(degrees: 180))
                                            .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                                        } else {
                                            LineView(post: post, chat: model.database.chat)
                                                .padding([.leading], 3)
                                                .rotationEffect(Angle(degrees: 180))
                                                .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                                        }
                                    } else {
                                        Rectangle()
                                            .fill(.red)
                                            .frame(width: metrics.size.width, height: 1.5)
                                            .padding(2)
                                            .rotationEffect(Angle(degrees: 180))
                                            .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                                    }
                                }
                            }
                            Spacer(minLength: 0)
                        }
                        .background(
                            GeometryReader { proxy in
                                Color.clear.preference(
                                    key: ViewOffsetKey.self,
                                    value: -1 * proxy.frame(in: .named(spaceName)).origin.y
                                )
                            }
                        )
                        .onPreferenceChange(
                            ViewOffsetKey.self,
                            perform: { scrollViewOffsetFromTop in
                                let offset = max(scrollViewOffsetFromTop, 0)
                                if offset >= scrollViewSize.height - wholeSize.height - 50 {
                                    if model.interactiveChatPaused, offset >= previousOffset {
                                        model.endOfInteractiveChatReachedWhenPaused()
                                    }
                                } else if !model.interactiveChatPaused {
                                    if !model.interactiveChatPosts.isEmpty {
                                        model.pauseInteractiveChat()
                                    }
                                }
                                previousOffset = offset
                            }
                        )
                        .frame(minHeight: metrics.size.height)
                    }
                }
                .foregroundColor(.white)
                .rotationEffect(Angle(degrees: 180))
                .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                .coordinateSpace(name: spaceName)
            }
        }
    }
}

private struct HypeTrainView: View {
    @EnvironmentObject var model: Model

    var body: some View {
        VStack(spacing: 0) {
            Rectangle()
                .foregroundColor(.clear)
                .background(.clear)
                .frame(height: 1)
            VStack {
                if let level = model.hypeTrainLevel {
                    HStack(spacing: 0) {
                        let train = HStack(spacing: 0) {
                            Image(systemName: "train.side.rear.car")
                            Image(systemName: "train.side.middle.car")
                            Image(systemName: "train.side.middle.car")
                            Image(systemName: "train.side.middle.car")
                            Image(systemName: "train.side.front.car")
                        }
                        if #available(iOS 18.0, *) {
                            train
                                .symbolEffect(
                                    .wiggle.forward.byLayer,
                                    options: .repeat(.periodic(delay: 2.0))
                                )
                        } else {
                            train
                        }
                        Spacer()
                        Text("LEVEL \(level)")
                        Button {
                            model.removeHypeTrain()
                        } label: {
                            Image(systemName: "xmark")
                                .font(.footnote)
                                .frame(width: 25, height: 25)
                                .overlay(
                                    Circle()
                                        .stroke(.secondary)
                                )
                                .padding([.leading], 15)
                        }
                    }
                    .foregroundColor(.white)
                    .padding(10)
                }
                if let progress = model.hypeTrainProgress, let goal = model.hypeTrainGoal {
                    ProgressView(value: Float(progress), total: Float(goal))
                        .accentColor(.white)
                        .scaleEffect(x: 1, y: 4, anchor: .center)
                        .padding([.top, .leading, .trailing], 10)
                        .padding([.bottom], 20)
                }
            }
            .background(RgbColor(red: 0x64, green: 0x41, blue: 0xA5).color())
            Spacer()
        }
    }
}

private struct ChatView: View {
    @EnvironmentObject var model: Model

    var body: some View {
        ZStack {
            MessagesView()
            if model.interactiveChatPaused {
                ChatInfo(
                    message: String(localized: "Chat paused: \(model.pausedInteractiveChatPostsCount) new messages")
                )
                .padding(2)
            }
            HypeTrainView()
        }
    }
}

private struct AlertsMessagesView: View {
    @EnvironmentObject var model: Model
    private let spaceName = "scroll"
    @State var wholeSize: CGSize = .zero
    @State var scrollViewSize: CGSize = .zero

    private func shouldShowMessage(highlight: ChatHighlight) -> Bool {
        if highlight.kind == .firstMessage && !model.showFirstTimeChatterMessage {
            return false
        }
        if highlight.kind == .newFollower && !model.showNewFollowerMessage {
            return false
        }
        return true
    }

    var body: some View {
        GeometryReader { metrics in
            ChildSizeReader(size: $wholeSize) {
                ScrollView {
                    ChildSizeReader(size: $scrollViewSize) {
                        VStack {
                            LazyVStack(alignment: .leading, spacing: 1) {
                                ForEach(model.interactiveChatAlertsPosts) { post in
                                    if post.user != nil {
                                        if let highlight = post.highlight {
                                            if shouldShowMessage(highlight: highlight) {
                                                HStack(spacing: 0) {
                                                    Rectangle()
                                                        .frame(width: 3)
                                                        .foregroundColor(highlight.color)
                                                    VStack(alignment: .leading, spacing: 1) {
                                                        HighlightMessageView(
                                                            image: highlight.image,
                                                            name: highlight.title
                                                        )
                                                        LineView(
                                                            post: post,
                                                            chat: model.database.chat
                                                        )
                                                    }
                                                }
                                                .rotationEffect(Angle(degrees: 180))
                                                .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                                            }
                                        } else {
                                            LineView(post: post, chat: model.database.chat)
                                                .padding([.leading], 3)
                                                .rotationEffect(Angle(degrees: 180))
                                                .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                                        }
                                    } else {
                                        Rectangle()
                                            .fill(.red)
                                            .frame(width: metrics.size.width, height: 1.5)
                                            .padding(2)
                                            .rotationEffect(Angle(degrees: 180))
                                            .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                                    }
                                }
                            }
                            Spacer(minLength: 0)
                        }
                        .background(
                            GeometryReader { proxy in
                                Color.clear.preference(
                                    key: ViewOffsetKey.self,
                                    value: -1 * proxy.frame(in: .named(spaceName)).origin.y
                                )
                            }
                        )
                        .onPreferenceChange(
                            ViewOffsetKey.self,
                            perform: { scrollViewOffsetFromTop in
                                let offset = max(scrollViewOffsetFromTop, 0)
                                if offset >= scrollViewSize.height - wholeSize.height - 50 {
                                    if model.interactiveChatAlertsPaused, offset >= previousOffset {
                                        model.endOfInteractiveChatAlertsReachedWhenPaused()
                                    }
                                } else if !model.interactiveChatAlertsPaused {
                                    if !model.interactiveChatAlertsPosts.isEmpty {
                                        model.pauseInteractiveChatAlerts()
                                    }
                                }
                                previousOffset = offset
                            }
                        )
                        .frame(minHeight: metrics.size.height)
                    }
                }
                .foregroundColor(.white)
                .rotationEffect(Angle(degrees: 180))
                .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                .coordinateSpace(name: spaceName)
            }
        }
    }
}

private struct ChatAlertsView: View {
    @EnvironmentObject var model: Model

    var body: some View {
        ZStack {
            AlertsMessagesView()
            if model.interactiveChatAlertsPaused {
                ChatInfo(
                    message: String(localized: "Chat paused: \(model.pausedInteractiveChatAlertsPostsCount) new alerts")
                )
                .padding(2)
            }
            HypeTrainView()
        }
    }
}

private struct ControlAlertsButtonView: View {
    @EnvironmentObject var model: Model

    var body: some View {
        Button(action: {
            model.showAllInteractiveChatMessage.toggle()
        }, label: {
            Image(systemName: model
                .showAllInteractiveChatMessage ? "megaphone" : "megaphone.fill")
                .font(.title)
                .padding(5)
        })
    }
}

private struct ControlView: View {
    @EnvironmentObject var model: Model
    @Binding var message: String

    var body: some View {
        TextField(text: $message) {
            Text("Send message")
                .foregroundColor(.gray)
        }
        .submitLabel(.send)
        .onSubmit {
            if !message.isEmpty {
                model.sendChatMessage(message: message)
            }
            message = ""
        }
        .padding(5)
        .foregroundColor(.white)
        ControlAlertsButtonView()
    }
}

private struct AlertsControlView: View {
    @EnvironmentObject var model: Model
    @State var message: String = ""

    var body: some View {
        Button(action: {
            model.showFirstTimeChatterMessage.toggle()
            model.database.chat.showFirstTimeChatterMessage = model.showFirstTimeChatterMessage
        }, label: {
            Image(systemName: model
                .showFirstTimeChatterMessage ? "bubble.left.fill" : "bubble.left")
                .font(.title)
                .padding(5)
        })
        Button(action: {
            model.showNewFollowerMessage.toggle()
            model.database.chat.showNewFollowerMessage = model.showNewFollowerMessage
        }, label: {
            Image(systemName: model.showNewFollowerMessage ? "medal.fill" : "medal")
                .font(.title)
                .padding(5)
        })
        Spacer()
        ControlAlertsButtonView()
    }
}

struct QuickButtonChatView: View {
    @EnvironmentObject var model: Model
    @State var message: String = ""

    var body: some View {
        VStack {
            if model.showAllInteractiveChatMessage {
                ChatView()
            } else {
                ChatAlertsView()
            }
            HStack {
                if model.showAllInteractiveChatMessage {
                    ControlView(message: $message)
                } else {
                    AlertsControlView()
                }
            }
            .frame(height: 50)
            .border(.gray)
            .padding([.leading, .trailing], 5)
        }
        .background(.black)
        .navigationTitle("Chat")
    }
}



---
File: /Moblin/View/Settings/Chat/ChatBotSettingsView.swift
---

import SwiftUI

private struct PermissionsSettingsView: View {
    // periphery:ignore
    @EnvironmentObject var model: Model
    var permissions: SettingsChatBotPermissionsCommand
    @State private var minimumSubscriberTier: Int

    init(permissions: SettingsChatBotPermissionsCommand) {
        self.permissions = permissions
        minimumSubscriberTier = permissions.minimumSubscriberTier!
    }

    var body: some View {
        Form {
            Toggle(isOn: Binding(get: {
                permissions.moderatorsEnabled
            }, set: { value in
                permissions.moderatorsEnabled = value
            }), label: {
                Text("Moderators")
            })
            Toggle(isOn: Binding(get: {
                permissions.subscribersEnabled!
            }, set: { value in
                permissions.subscribersEnabled = value
            }), label: {
                Text("Subscribers")
            })
            Picker(selection: $minimumSubscriberTier) {
                ForEach([3, 2, 1], id: \.self) { tier in
                    Text(String(tier))
                }
            } label: {
                Text("Minimum subscriber tier")
            }
            .onChange(of: minimumSubscriberTier) { value in
                permissions.minimumSubscriberTier = value
            }
            Toggle(isOn: Binding(get: {
                permissions.othersEnabled
            }, set: { value in
                permissions.othersEnabled = value
            }), label: {
                Text("Others")
            })
        }
        .navigationTitle("Permissions")
    }
}

struct ChatBotCommandsSettingsView: View {
    @EnvironmentObject var model: Model

    private var permissions: SettingsChatBotPermissions {
        model.database.chat.botCommandPermissions!
    }

    var body: some View {
        Form {
            Section {
                NavigationLink {
                    PermissionsSettingsView(permissions: permissions.fix)
                } label: {
                    Text("!moblin obs fix")
                }
            } footer: {
                Text("Fix OBS input.")
            }
            Section {
                NavigationLink {
                    PermissionsSettingsView(permissions: permissions.alert!)
                } label: {
                    Text("!moblin alert <name>")
                }
            } footer: {
                Text("Trigger alerts. Configure alert names in alert widgets.")
            }
            Section {
                NavigationLink {
                    PermissionsSettingsView(permissions: permissions.fax!)
                } label: {
                    Text("!moblin fax <url>")
                }
            } footer: {
                Text("Fax the streamer images.")
            }
            Section {
                NavigationLink {
                    PermissionsSettingsView(permissions: permissions.snapshot!)
                } label: {
                    Text("!moblin snapshot <optional message>")
                }
            } footer: {
                Text("Take snapshot.")
            }
            Section {
                NavigationLink {
                    PermissionsSettingsView(permissions: permissions.filter!)
                } label: {
                    Text("!moblin filter <filter> <on/off>")
                }
            } footer: {
                VStack(alignment: .leading) {
                    Text("Turn a filter on or off.")
                    Text("")
                    Text("<filter> is movie, grayscale, sepia, triple, pixellate or 4:3.")
                    Text("")
                    Text("<on/off> is on or off.")
                }
            }
            Section {
                NavigationLink {
                    PermissionsSettingsView(permissions: permissions.map)
                } label: {
                    Text("!moblin map zoom out")
                }
            } footer: {
                Text("Zoom out map widget temporarily.")
            }
            Section {
                NavigationLink {
                    PermissionsSettingsView(permissions: permissions.tts)
                } label: {
                    Text("!moblin tts/say ...")
                }
            } footer: {
                VStack(alignment: .leading) {
                    Text("!moblin tts on")
                    Text("Turn on chat text to speech.")
                    Text("")
                    Text("!moblin tts off")
                    Text("Turn off chat text to speech.")
                    Text("")
                    Text("!moblin say <message>")
                    Text("Say given message.")
                }
            }
            Section {
                NavigationLink {
                    PermissionsSettingsView(permissions: permissions.audio!)
                } label: {
                    Text("!moblin mute/unmute")
                }
            } footer: {
                VStack(alignment: .leading) {
                    Text("!moblin mute")
                    Text("Mute audio.")
                    Text("")
                    Text("!moblin unmute")
                    Text("Unmute audio.")
                }
            }
            Section {
                NavigationLink {
                    PermissionsSettingsView(permissions: permissions.tesla!)
                } label: {
                    Text("!moblin tesla ...")
                }
            } footer: {
                VStack(alignment: .leading) {
                    Text("!moblin tesla trunk open")
                    Text("Open the trunk.")
                    Text("")
                    Text("!moblin tesla trunk close")
                    Text("Close the trunk.")
                    Text("")
                    Text("!moblin tesla media next")
                    Text("Next track.")
                    Text("")
                    Text("!moblin tesla media previous")
                    Text("Previous track.")
                    Text("")
                    Text("!moblin tesla media toggle-playback")
                    Text("Toggle playback.")
                }
            }
        }
        .navigationTitle("Commands")
    }
}

struct ChatBotSettingsView: View {
    @EnvironmentObject var model: Model

    var body: some View {
        Form {
            Section {
                NavigationLink { ChatBotCommandsSettingsView() } label: {
                    Text("Commands")
                }
            }
            Section {
                Toggle(isOn: Binding(get: {
                    model.database.chat.botSendLowBatteryWarning!
                }, set: { value in
                    model.database.chat.botSendLowBatteryWarning = value
                }), label: {
                    Text("Send low battery message")
                })
            }
        }
        .navigationTitle("Bot")
    }
}



---
File: /Moblin/View/Settings/Chat/ChatSettingsView.swift
---

import SwiftUI

struct ChatSettingsView: View {
    @EnvironmentObject var model: Model
    @State var timestampColor: Color
    @State var usernameColor: Color
    @State var messageColor: Color
    @State var backgroundColor: Color
    @State var shadowColor: Color
    @State var height: Double
    @State var width: Double
    @State var fontSize: Float

    func submitMaximumAge(value: String) {
        guard let maximumAge = Int(value) else {
            return
        }
        guard maximumAge > 0 else {
            return
        }
        model.database.chat.maximumAge = maximumAge
    }

    var body: some View {
        Form {
            Section {
                Toggle("Enabled", isOn: Binding(get: {
                    model.database.chat.enabled!
                }, set: { value in
                    model.database.chat.enabled = value
                    model.reloadChats()
                }))
            }
            Section {
                HStack {
                    Text("Font size")
                    Slider(
                        value: $fontSize,
                        in: 10 ... 30,
                        step: 1,
                        onEditingChanged: { begin in
                            guard !begin else {
                                return
                            }
                            model.database.chat.fontSize = fontSize
                            model.reloadChatMessages()
                        }
                    )
                    .onChange(of: fontSize) { value in
                        model.database.chat.fontSize = value
                        model.reloadChatMessages()
                    }
                    Text(String(Int(fontSize)))
                        .frame(width: 25)
                }
                if model.database.showAllSettings! {
                    Toggle(isOn: Binding(get: {
                        model.database.chat.timestampColorEnabled
                    }, set: { value in
                        model.database.chat.timestampColorEnabled = value
                        model.reloadChatMessages()
                    })) {
                        Text("Timestamp")
                    }
                    Toggle(isOn: Binding(get: {
                        model.database.chat.boldUsername
                    }, set: { value in
                        model.database.chat.boldUsername = value
                        model.reloadChatMessages()
                    })) {
                        Text("Bold username")
                    }
                    Toggle(isOn: Binding(get: {
                        model.database.chat.boldMessage
                    }, set: { value in
                        model.database.chat.boldMessage = value
                        model.reloadChatMessages()
                    })) {
                        Text("Bold message")
                    }
                    Toggle(isOn: Binding(get: {
                        model.database.chat.badges!
                    }, set: { value in
                        model.database.chat.badges = value
                        model.reloadChatMessages()
                    })) {
                        Text("Badges")
                    }
                    Toggle(isOn: Binding(get: {
                        model.database.chat.animatedEmotes
                    }, set: { value in
                        model.database.chat.animatedEmotes = value
                        model.reloadChatMessages()
                    })) {
                        Text("Animated emotes")
                    }
                    NavigationLink {
                        TextEditView(
                            title: String(localized: "Maximum age"),
                            value: String(model.database.chat.maximumAge!),
                            footers: [String(localized: "Maximum message age in seconds.")]
                        ) {
                            submitMaximumAge(value: $0)
                        }
                    } label: {
                        Toggle(isOn: Binding(get: {
                            model.database.chat.maximumAgeEnabled!
                        }, set: { value in
                            model.database.chat.maximumAgeEnabled = value
                        })) {
                            TextItemView(
                                name: String(localized: "Maximum age"),
                                value: String(model.database.chat.maximumAge!)
                            )
                        }
                    }
                }
                NavigationLink {
                    ChatUsernamesToIgnoreSettingsView()
                } label: {
                    Text("Usernames to ignore")
                }
                NavigationLink {
                    ChatTextToSpeechSettingsView(
                        rate: model.database.chat.textToSpeechRate!,
                        volume: model.database.chat.textToSpeechSayVolume!
                    )
                } label: {
                    Toggle(isOn: Binding(get: {
                        model.database.chat.textToSpeechEnabled!
                    }, set: { value in
                        model.database.chat.textToSpeechEnabled = value
                        if !value {
                            model.chatTextToSpeech.reset(running: true)
                        }
                    })) {
                        Text("Text to speech")
                    }
                }
                NavigationLink {
                    ChatBotSettingsView()
                } label: {
                    Toggle(isOn: Binding(get: {
                        model.database.chat.botEnabled!
                    }, set: { value in
                        model.database.chat.botEnabled = value
                    })) {
                        Text("Bot")
                    }
                }
                if model.database.showAllSettings! {
                    Toggle(isOn: Binding(get: {
                        model.database.chat.mirrored!
                    }, set: { value in
                        model.database.chat.mirrored = value
                        model.objectWillChange.send()
                    })) {
                        Text("Mirrored")
                    }
                }
            } header: {
                Text("General")
            } footer: {
                Text(
                    "Animated emotes are fairly CPU intensive. Disable for less power usage."
                )
            }
            Section("Geometry") {
                HStack {
                    Text("Height")
                    Slider(
                        value: $height,
                        in: 0.2 ... 1.0,
                        step: 0.05,
                        onEditingChanged: { begin in
                            guard !begin else {
                                return
                            }
                            model.database.chat.height = height
                            model.reloadChatMessages()
                        }
                    )
                    .onChange(of: height) { value in
                        model.database.chat.height = value
                    }
                    Text("\(Int(100 * height)) %")
                        .frame(width: 55)
                }
                HStack {
                    Text("Width")
                    Slider(
                        value: $width,
                        in: 0.2 ... 1.0,
                        step: 0.05,
                        onEditingChanged: { begin in
                            guard !begin else {
                                return
                            }
                            model.database.chat.width = width
                            model.reloadChatMessages()
                        }
                    )
                    .onChange(of: width) { value in
                        model.database.chat.width = value
                    }
                    Text("\(Int(100 * width)) %")
                        .frame(width: 55)
                }
            }
            if model.database.showAllSettings! {
                Section {
                    ColorPicker("Timestamp", selection: $timestampColor, supportsOpacity: false)
                        .onChange(of: timestampColor) { _ in
                            guard let color = timestampColor.toRgb() else {
                                return
                            }
                            model.database.chat.timestampColor = color
                            model.reloadChatMessages()
                        }
                    ColorPicker("Username", selection: $usernameColor, supportsOpacity: false)
                        .onChange(of: usernameColor) { _ in
                            guard let color = usernameColor.toRgb() else {
                                return
                            }
                            model.database.chat.usernameColor = color
                            model.reloadChatMessages()
                        }
                    ColorPicker("Message", selection: $messageColor, supportsOpacity: false)
                        .onChange(of: messageColor) { _ in
                            guard let color = messageColor.toRgb() else {
                                return
                            }
                            model.database.chat.messageColor = color
                            model.reloadChatMessages()
                        }
                    Toggle(isOn: Binding(get: {
                        model.database.chat.backgroundColorEnabled
                    }, set: { value in
                        model.database.chat.backgroundColorEnabled = value
                        model.reloadChatMessages()
                    })) {
                        ColorPicker("Background", selection: $backgroundColor, supportsOpacity: false)
                            .onChange(of: backgroundColor) { _ in
                                guard let color = backgroundColor.toRgb() else {
                                    return
                                }
                                model.database.chat.backgroundColor = color
                                model.reloadChatMessages()
                            }
                    }
                    Toggle(isOn: Binding(get: {
                        model.database.chat.shadowColorEnabled
                    }, set: { value in
                        model.database.chat.shadowColorEnabled = value
                        model.reloadChatMessages()
                    })) {
                        ColorPicker("Border", selection: $shadowColor, supportsOpacity: false)
                            .onChange(of: shadowColor) { _ in
                                guard let color = shadowColor.toRgb() else {
                                    return
                                }
                                model.database.chat.shadowColor = color
                                model.reloadChatMessages()
                            }
                    }
                    Toggle(isOn: Binding(get: {
                        model.database.chat.meInUsernameColor!
                    }, set: { value in
                        model.database.chat.meInUsernameColor = value
                    })) {
                        Text("Me in username color")
                    }
                } header: {
                    Text("Colors")
                } footer: {
                    Text("Border is fairly CPU intensive. Disable for less power usage.")
                }
            }
        }
        .navigationTitle("Chat")
    }
}



---
File: /Moblin/View/Settings/Chat/ChatTextToSpeechSettingsView.swift
---

import AVFAudio
import SwiftUI

struct ChatTextToSpeechSettingsView: View {
    @EnvironmentObject var model: Model
    @State var rate: Float
    @State var volume: Float

    private func onVoiceChange(languageCode: String, voice: String) {
        model.database.chat.textToSpeechLanguageVoices![languageCode] = voice
        model.chatTextToSpeech.setVoices(voices: model.database.chat.textToSpeechLanguageVoices!)
    }

    var body: some View {
        Form {
            Section {
                NavigationLink {
                    VoicesView(
                        textToSpeechLanguageVoices: model.database.chat.textToSpeechLanguageVoices!,
                        onVoiceChange: onVoiceChange
                    )
                } label: {
                    Text("Voices")
                }
                HStack {
                    Image(systemName: "tortoise.fill")
                    Slider(
                        value: $rate,
                        in: 0.3 ... 0.6,
                        step: 0.01,
                        onEditingChanged: { begin in
                            guard !begin else {
                                return
                            }
                            model.database.chat.textToSpeechRate = rate
                            model.chatTextToSpeech.setRate(rate: rate)
                        }
                    )
                    Image(systemName: "hare.fill")
                }
                HStack {
                    Image(systemName: "volume.1.fill")
                    Slider(
                        value: $volume,
                        in: 0.3 ... 1.0,
                        step: 0.01,
                        onEditingChanged: { begin in
                            guard !begin else {
                                return
                            }
                            model.database.chat.textToSpeechSayVolume = volume
                            model.chatTextToSpeech.setVolume(volume: volume)
                        }
                    )
                    Image(systemName: "volume.3.fill")
                }
            }
            Section {
                Toggle(isOn: Binding(get: {
                    model.database.chat.textToSpeechDetectLanguagePerMessage!
                }, set: { value in
                    model.database.chat.textToSpeechDetectLanguagePerMessage = value
                    model.chatTextToSpeech.setDetectLanguagePerMessage(value: value)
                })) {
                    Text("Detect language per message")
                }
                Toggle(isOn: Binding(get: {
                    model.database.chat.textToSpeechSayUsername!
                }, set: { value in
                    model.database.chat.textToSpeechSayUsername = value
                    model.chatTextToSpeech.setSayUsername(value: value)
                })) {
                    Text("Say username")
                }
                Toggle(isOn: Binding(get: {
                    model.database.chat.textToSpeechSubscribersOnly!
                }, set: { value in
                    model.database.chat.textToSpeechSubscribersOnly = value
                })) {
                    Text("Subscribers only")
                }
            } footer: {
                Text("Subscribers only is not available for all platforms.")
            }
            Section {
                Toggle(isOn: Binding(get: {
                    model.database.chat.textToSpeechFilter!
                }, set: { value in
                    model.database.chat.textToSpeechFilter = value
                    model.chatTextToSpeech.setFilter(value: value)
                })) {
                    Text("Filter")
                }
            } footer: {
                Text("Do not say messages that are likely spam or bot commands.")
            }
            Section {
                Toggle(isOn: Binding(get: {
                    model.database.chat.textToSpeechFilterMentions!
                }, set: { value in
                    model.database.chat.textToSpeechFilterMentions = value
                    model.chatTextToSpeech.setFilterMentions(value: value)
                })) {
                    Text("Filter mentions")
                }
            } footer: {
                Text("Do not say messages that contains mentions, except when you are mentioned.")
            }
        }
        .onAppear {
            if #available(iOS 17.0, *) {
                AVSpeechSynthesizer.requestPersonalVoiceAuthorization { _ in
                }
            }
        }
        .navigationTitle("Text to speech")
    }
}



---
File: /Moblin/View/Settings/Chat/ChatUsernamesToIgnoreSettingsView.swift
---

import SwiftUI

private struct UsernameEditView: View {
    @State var value: String
    var onSubmit: (String) -> Void
    @State private var changed = false
    @State private var submitted = false

    private func submit() {
        submitted = true
        value = value.trim()
        onSubmit(value)
    }

    var body: some View {
        TextField("", text: $value)
            .keyboardType(.default)
            .textInputAutocapitalization(.never)
            .disableAutocorrection(true)
            .onChange(of: value) { _ in
                changed = true
            }
            .onSubmit {
                submit()
            }
            .submitLabel(.done)
            .onDisappear {
                if changed && !submitted {
                    submit()
                }
            }
    }
}

struct ChatUsernamesToIgnoreSettingsView: View {
    @EnvironmentObject var model: Model

    private func onSubmit(_ username: SettingsChatUsername, _ value: String) {
        username.value = value
    }

    var body: some View {
        Form {
            Section {
                List {
                    ForEach(model.database.chat.usernamesToIgnore!) { username in
                        UsernameEditView(
                            value: username.value,
                            onSubmit: { value in onSubmit(username, value) }
                        )
                    }
                    .onMove(perform: { froms, to in
                        model.database.chat.usernamesToIgnore!.move(fromOffsets: froms, toOffset: to)
                    })
                    .onDelete(perform: { offsets in
                        model.database.chat.usernamesToIgnore!.remove(atOffsets: offsets)
                    })
                }
                AddButtonView(action: {
                    model.database.chat.usernamesToIgnore!.append(SettingsChatUsername())
                })
            } footer: {
                SwipeLeftToRemoveHelpView(kind: String(localized: "a username"))
            }
        }
        .navigationTitle("Usernames to ignore")
    }
}



---
File: /Moblin/View/Settings/Streams/Stream/Chat/StreamEmotesSettingsView.swift
---

import SwiftUI

struct StreamEmotesSettingsView: View {
    @EnvironmentObject var model: Model
    var stream: SettingsStream

    var body: some View {
        Form {
            Section {
                Toggle("BTTV", isOn: Binding(get: {
                    stream.chat!.bttvEmotes
                }, set: { value in
                    stream.chat!.bttvEmotes = value
                    if stream.enabled {
                        model.bttvEmotesEnabledUpdated()
                    }
                }))
                Toggle("FFZ", isOn: Binding(get: {
                    stream.chat!.ffzEmotes
                }, set: { value in
                    stream.chat!.ffzEmotes = value
                    if stream.enabled {
                        model.ffzEmotesEnabledUpdated()
                    }
                }))
                Toggle("7TV", isOn: Binding(get: {
                    stream.chat!.seventvEmotes
                }, set: { value in
                    stream.chat!.seventvEmotes = value
                    if stream.enabled {
                        model.seventvEmotesEnabledUpdated()
                    }
                }))
            }
        }
        .navigationTitle("Emotes")
    }
}



---
File: /Moblin/View/Settings/Streams/Stream/Kick/StreamKickSettingsView.swift
---

import SwiftUI

struct StreamKickSettingsView: View {
    @EnvironmentObject var model: Model
    var stream: SettingsStream

    func submitChannelName(value: String) {
        stream.kickChannelName = value
        if stream.enabled {
            model.kickChannelNameUpdated()
        }
    }

    var body: some View {
        Form {
            Section {
                TextEditNavigationView(
                    title: String(localized: "Channel name"),
                    value: stream.kickChannelName!,
                    onSubmit: submitChannelName
                )
            }
        }
        .navigationTitle("Kick")
    }
}



---
File: /Moblin/View/Settings/Streams/Stream/Wizard/Platform/StreamWizardKickSettingsView.swift
---

import SwiftUI

struct StreamWizardKickSettingsView: View {
    @EnvironmentObject private var model: Model

    private func channelName() -> String {
        return model.wizardKickChannelName.trim()
    }

    private func nextDisabled() -> Bool {
        return channelName().isEmpty
    }

    var body: some View {
        Form {
            Section {
                TextField("MyChannel", text: $model.wizardKickChannelName)
                    .disableAutocorrection(true)
            } header: {
                Text("Channel name")
            }
            Section {
                NavigationLink {
                    StreamWizardNetworkSetupSettingsView(platform: String(localized: "Kick"))
                } label: {
                    WizardNextButtonView()
                }
                .disabled(nextDisabled())
            }
        }
        .onAppear {
            model.wizardPlatform = .kick
            model.wizardName = "Kick"
        }
        .navigationTitle("Kick")
        .toolbar {
            CreateStreamWizardToolbar()
        }
    }
}



---
File: /Moblin/View/Settings/Streams/Stream/Wizard/StreamWizardChatSettingsView.swift
---

import SwiftUI

struct StreamWizardChatSettingsView: View {
    @EnvironmentObject private var model: Model

    var body: some View {
        Form {
            Section {
                Toggle(isOn: $model.wizardChatBttv, label: {
                    Text("BTTV emotes")
                })
                Toggle(isOn: $model.wizardChatFfz, label: {
                    Text("FFZ emotes")
                })
                Toggle(isOn: $model.wizardChatSeventv, label: {
                    Text("7TV emotes")
                })
            }
            Section {
                if model.wizardNetworkSetup == .direct {
                    NavigationLink {
                        StreamWizardSummarySettingsView()
                    } label: {
                        WizardNextButtonView()
                    }
                } else {
                    NavigationLink {
                        StreamWizardObsRemoteControlSettingsView()
                    } label: {
                        WizardNextButtonView()
                    }
                }
            }
        }
        .navigationTitle("Chat")
        .toolbar {
            CreateStreamWizardToolbar()
        }
    }
}



---
File: /Moblin/View/Settings/Watch/Chat/WatchChatSettingsView.swift
---

import SwiftUI

struct WatchChatSettingsView: View {
    @EnvironmentObject var model: Model
    @State var fontSize: Float

    var body: some View {
        Form {
            Section {
                HStack {
                    Text("Font size")
                    Slider(
                        value: $fontSize,
                        in: 10 ... 30,
                        step: 1,
                        onEditingChanged: { begin in
                            guard !begin else {
                                return
                            }
                            model.database.watch!.chat.fontSize = fontSize
                            model.sendSettingsToWatch()
                        }
                    )
                    .onChange(of: fontSize) { _ in
                        model.database.watch!.chat.fontSize = fontSize
                    }
                    Text(String(Int(fontSize)))
                        .frame(width: 25)
                }
                Toggle(isOn: Binding(get: {
                    model.database.watch!.chat.timestampEnabled!
                }, set: { value in
                    model.database.watch!.chat.timestampEnabled = value
                    model.sendSettingsToWatch()
                })) {
                    Text("Timestamp")
                }
                Toggle(isOn: Binding(get: {
                    model.database.watch!.chat.badges!
                }, set: { value in
                    model.database.watch!.chat.badges = value
                    model.sendSettingsToWatch()
                })) {
                    Text("Badges")
                }
                Toggle(isOn: Binding(get: {
                    model.database.watch!.chat.notificationOnMessage!
                }, set: { value in
                    model.database.watch!.chat.notificationOnMessage = value
                    model.sendSettingsToWatch()
                })) {
                    Text("Notification on message")
                }
            } header: {
                Text("General")
            }
        }
        .onDisappear {
            model.sendSettingsToWatch()
        }
        .navigationTitle("Chat")
    }
}



---
File: /Moblin/View/Stream/Overlay/StreamOverlayChatView.swift
---

import Collections
import SDWebImageSwiftUI
import SwiftUI
import WrappingHStack

private let borderWidth = 1.5

private struct HighlightMessageView: View {
    let chat: SettingsChat
    let image: String
    let name: String

    private func messageColor() -> Color {
        return chat.messageColor.color()
    }

    private func backgroundColor() -> Color {
        if chat.backgroundColorEnabled {
            return chat.backgroundColor.color().opacity(0.6)
        } else {
            return .clear
        }
    }

    private func shadowColor() -> Color {
        if chat.shadowColorEnabled {
            return chat.shadowColor.color()
        } else {
            return .clear
        }
    }

    var body: some View {
        let messageColor = messageColor()
        let shadowColor = shadowColor()
        WrappingHStack(
            alignment: .leading,
            horizontalSpacing: 0,
            verticalSpacing: 0,
            fitContentWidth: true
        ) {
            Image(systemName: image)
            Text(" ")
            Text(name)
        }
        .foregroundColor(messageColor)
        .stroke(color: shadowColor, width: chat.shadowColorEnabled ? borderWidth : 0)
        .padding([.leading], 5)
        .font(.system(size: CGFloat(chat.fontSize)))
        .background(backgroundColor())
        .foregroundColor(.white)
        .cornerRadius(5)
    }
}

private struct LineView: View {
    var post: ChatPost
    var chat: SettingsChat

    private func usernameColor() -> Color {
        if let color = post.userColor {
            return color.color()
        } else {
            return chat.usernameColor.color()
        }
    }

    private func messageColor(usernameColor: Color) -> Color {
        if post.isAction && chat.meInUsernameColor! {
            return usernameColor
        } else {
            return chat.messageColor.color()
        }
    }

    private func backgroundColor() -> Color {
        if chat.backgroundColorEnabled {
            return chat.backgroundColor.color().opacity(0.6)
        } else {
            return .clear
        }
    }

    private func shadowColor() -> Color {
        if chat.shadowColorEnabled {
            return chat.shadowColor.color()
        } else {
            return .clear
        }
    }

    var body: some View {
        let timestampColor = chat.timestampColor.color()
        let usernameColor = usernameColor()
        let messageColor = messageColor(usernameColor: usernameColor)
        let shadowColor = shadowColor()
        WrappingHStack(
            alignment: .leading,
            horizontalSpacing: 0,
            verticalSpacing: 0,
            fitContentWidth: true
        ) {
            if chat.timestampColorEnabled {
                Text("\(post.timestamp) ")
                    .foregroundColor(timestampColor)
            }
            if chat.badges! {
                ForEach(post.userBadges, id: \.self) { url in
                    CacheAsyncImage(url: url) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                    } placeholder: {
                        EmptyView()
                    }
                    .padding(2)
                    .frame(height: CGFloat(chat.fontSize * 1.4))
                }
            }
            Text(post.user!)
                .foregroundColor(usernameColor)
                .lineLimit(1)
                .padding([.trailing], 0)
                .bold(chat.boldUsername)
            if post.isRedemption() {
                Text(" ")
            } else {
                Text(": ")
            }
            ForEach(post.segments, id: \.id) { segment in
                if let text = segment.text {
                    Text(text)
                        .foregroundColor(messageColor)
                        .bold(chat.boldMessage)
                        .italic(post.isAction)
                }
                if let url = segment.url {
                    if chat.animatedEmotes {
                        WebImage(url: url)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .padding([.top, .bottom], chat.shadowColorEnabled ? 1.5 : 0)
                            .frame(height: CGFloat(chat.fontSize * 1.7))
                    } else {
                        CacheAsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fit)
                        } placeholder: {
                            EmptyView()
                        }
                        .padding([.top, .bottom], chat.shadowColorEnabled ? 1.5 : 0)
                        .frame(height: CGFloat(chat.fontSize * 1.7))
                    }
                    Text(" ")
                }
            }
        }
        .stroke(color: shadowColor, width: chat.shadowColorEnabled ? borderWidth : 0)
        .padding([.leading], 5)
        .font(.system(size: CGFloat(chat.fontSize)))
        .background(backgroundColor())
        .foregroundColor(.white)
        .cornerRadius(5)
    }
}

struct ViewOffsetKey: PreferenceKey {
    static var defaultValue = CGFloat.zero

    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value += nextValue()
    }
}

private var previousOffset = 0.0

struct StreamOverlayChatView: View {
    @EnvironmentObject var model: Model
    private let spaceName = "scroll"
    @State var wholeSize: CGSize = .zero
    @State var scrollViewSize: CGSize = .zero

    var body: some View {
        GeometryReader { metrics in
            VStack {
                Spacer()
                ChildSizeReader(size: $wholeSize) {
                    ScrollView {
                        ChildSizeReader(size: $scrollViewSize) {
                            VStack {
                                LazyVStack(alignment: .leading, spacing: 1) {
                                    ForEach(model.chatPosts) { post in
                                        if post.user != nil {
                                            if let highlight = post.highlight {
                                                HStack(spacing: 0) {
                                                    Rectangle()
                                                        .frame(width: 3)
                                                        .foregroundColor(highlight.color)
                                                    VStack(alignment: .leading, spacing: 1) {
                                                        HighlightMessageView(
                                                            chat: model.database.chat,
                                                            image: highlight.image,
                                                            name: highlight.title
                                                        )
                                                        LineView(
                                                            post: post,
                                                            chat: model.database.chat
                                                        )
                                                    }
                                                }
                                                .rotationEffect(Angle(degrees: 180))
                                                .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                                            } else {
                                                LineView(post: post, chat: model.database.chat)
                                                    .padding([.leading], 3)
                                                    .rotationEffect(Angle(degrees: 180))
                                                    .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                                            }
                                        } else {
                                            Rectangle()
                                                .fill(.red)
                                                .frame(width: metrics.size.width, height: 1.5)
                                                .padding(2)
                                                .rotationEffect(Angle(degrees: 180))
                                                .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                                        }
                                    }
                                }
                                Spacer(minLength: 0)
                            }
                            .background(
                                GeometryReader { proxy in
                                    Color.clear.preference(
                                        key: ViewOffsetKey.self,
                                        value: -1 * proxy.frame(in: .named(spaceName)).origin.y
                                    )
                                }
                            )
                            .onPreferenceChange(
                                ViewOffsetKey.self,
                                perform: { scrollViewOffsetFromTop in
                                    let offset = max(scrollViewOffsetFromTop, 0)
                                    if offset >= scrollViewSize.height - wholeSize.height - 50 {
                                        if model.chatPaused, offset >= previousOffset {
                                            model.endOfChatReachedWhenPaused()
                                        }
                                    } else if !model.chatPaused {
                                        if !model.chatPosts.isEmpty {
                                            model.pauseChat()
                                        }
                                    }
                                    previousOffset = offset
                                }
                            )
                            .frame(minHeight: metrics.size.height)
                        }
                    }
                    .foregroundColor(.white)
                    .rotationEffect(Angle(degrees: 180))
                    .scaleEffect(x: -1.0, y: 1.0, anchor: .center)
                    .coordinateSpace(name: spaceName)
                    .frame(width: metrics.size.width * model.database.chat.width!,
                           height: metrics.size.height * model.database.chat.height!)
                }
            }
        }
    }
}



---
File: /Moblin/Info.plist
---

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleIdentifier</key>
			<string></string>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLName</key>
			<string>com.eerimoq.Mobs</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>moblin</string>
			</array>
		</dict>
	</array>
	<key>ITSAppUsesNonExemptEncryption</key>
	<false/>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSAllowsArbitraryLoads</key>
		<true/>
	</dict>
	<key>NSCameraReactionEffectsEnabled</key>
	<true/>
	<key>NSUserActivityTypes</key>
	<array>
		<string>IntentIntent</string>
		<string>MuteIntent</string>
	</array>
	<key>UIBackgroundModes</key>
	<array>
		<string>audio</string>
		<string>location</string>
	</array>
</dict>
</plist>



---
File: /Moblin Screen Recording/Info.plist
---

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>NSExtension</key>
	<dict>
		<key>NSExtensionPointIdentifier</key>
		<string>com.apple.broadcast-services-upload</string>
		<key>NSExtensionPrincipalClass</key>
		<string>$(PRODUCT_MODULE_NAME).SampleHandler</string>
		<key>RPBroadcastProcessMode</key>
		<string>RPBroadcastProcessModeSampleBuffer</string>
	</dict>
</dict>
</plist>



---
File: /Moblin Watch/View/Chat/ChatView.swift
---

import SwiftUI
import WrappingHStack

private struct LineView: View {
    @EnvironmentObject var model: Model
    let post: ChatPost
    let fontSize: CGFloat

    var body: some View {
        WrappingHStack(
            alignment: .leading,
            horizontalSpacing: 0,
            verticalSpacing: 0,
            fitContentWidth: true
        ) {
            if model.settings.chat.timestampEnabled! {
                Text(post.timestamp + " ")
                    .foregroundColor(.gray)
            }
            if model.settings.chat.badges! {
                ForEach(post.userBadges, id: \.self) { url in
                    CacheImage(url: url) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                    }
                    .padding(2)
                    .frame(height: fontSize * 1.3)
                }
            }
            Text(post.user)
                .foregroundColor(post.userColor)
            if post.isRedemption() {
                Text(" ")
            } else {
                Text(": ")
            }
            ForEach(post.segments) { segment in
                if let text = segment.text {
                    Text(text)
                }
                if let url = segment.url {
                    CacheImage(url: url) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                    }
                    .frame(height: fontSize * 1.5)
                    Text(" ")
                }
            }
        }
    }
}

private struct HighlightView: View {
    let image: String
    let name: String

    var body: some View {
        WrappingHStack(
            alignment: .leading,
            horizontalSpacing: 0,
            verticalSpacing: 0,
            fitContentWidth: true
        ) {
            Image(systemName: image)
            Text(" ")
            Text(name)
        }
    }
}

private struct NormalView: View {
    @EnvironmentObject var model: Model
    let post: ChatPost
    let fontSize: CGFloat

    var body: some View {
        if let highlight = post.highlight {
            HStack(spacing: 0) {
                Rectangle()
                    .frame(width: 3)
                    .foregroundColor(highlight.color)
                    .padding([.trailing], 3)
                VStack(alignment: .leading) {
                    HighlightView(image: highlight.image, name: highlight.title)
                    LineView(post: post, fontSize: fontSize)
                }
            }
        } else {
            LineView(post: post, fontSize: fontSize)
        }
    }
}

private struct RedLineView: View {
    var body: some View {
        Rectangle()
            .fill(.red)
            .frame(height: 1.5)
            .padding(2)
    }
}

private struct InfoView: View {
    @EnvironmentObject var model: Model
    let post: ChatPost

    var body: some View {
        WrappingHStack(
            alignment: .leading,
            horizontalSpacing: 0,
            verticalSpacing: 0,
            fitContentWidth: true
        ) {
            ForEach(post.segments) { segment in
                if let text = segment.text {
                    Text(text + " ")
                }
            }
        }
        .italic()
    }
}

struct ChatView: View {
    @EnvironmentObject var model: Model

    private func fontSize() -> CGFloat {
        return CGFloat(model.settings.chat.fontSize)
    }

    var body: some View {
        ScrollView {
            LazyVStack(alignment: .leading) {
                if model.chatPosts.isEmpty {
                    Text("Chat is empty.")
                        .font(.system(size: fontSize()))
                } else {
                    ForEach(model.chatPosts) { post in
                        if post.kind == .normal {
                            NormalView(post: post, fontSize: fontSize())
                        } else if post.kind == .redLine {
                            RedLineView()
                        } else {
                            InfoView(post: post)
                        }
                    }
                    .font(.system(size: fontSize()))
                }
            }
        }
    }
}



---
File: /Moblin Watch/Info.plist
---

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>UIBackgroundModes</key>
	<array/>
	<key>WKBackgroundModes</key>
	<array>
		<string>workout-processing</string>
	</array>
</dict>
</plist>



---
File: /Moblin Widget/Info.plist
---

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>NSExtension</key>
	<dict>
		<key>NSExtensionPointIdentifier</key>
		<string>com.apple.widgetkit-extension</string>
	</dict>
</dict>
</plist>



---
File: /Moblin.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
---

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



---
File: /utils/assistant.py
---

import sys
import json
import random
import argparse
from aiohttp import web
import aiohttp
from websockets.sync.client import connect
from hashlib import sha256
from base64 import b64encode
import asyncio

DEFAULT_PORT = 2345
API_VERSION = '0.1'


def random_string():
    return random.randbytes(64).hex()


class Assistant:

    def __init__(self, password):
        self.password = password
        self.challenge = None
        self.salt = None
        self.streamer = None
        self.request_id = 0
        self.client_completions = {}

    async def handle_streamer(self, request):
        self.streamer = web.WebSocketResponse()
        await self.streamer.prepare(request)

        self.challenge = random_string()
        self.salt = random_string()
        await self.send_to_streamer({
            'hello': {
                'apiVersion': API_VERSION,
                'authentication': {
                    'challenge': self.challenge,
                    'salt': self.salt
                }
            }
        })

        async for message in self.streamer:
            if message.type == aiohttp.WSMsgType.TEXT:
                message = json.loads(message.data)

                for kind, data in message.items():
                    if kind == 'identify':
                        await self.handle_identify(data['authentication'])
                    elif kind == 'event':
                        await self.handle_event(data['data'])
                    elif kind == 'response':
                        await self.handle_response(data)
                    else:
                        print('Unknown message', message)
            else:
                print('Ignoring', message)

        return self.streamer

    async def send_to_streamer(self, message):
        if self.streamer is None:
            raise Exception('Streamer not connected')

        await self.streamer.send_str(json.dumps(message))

    def next_id(self):
        self.request_id += 1

        return self.request_id

    def hash_password(self):
        concatenated = self.password + self.salt
        hash = b64encode(sha256(
            concatenated.encode('utf-8')).digest()).decode('utf-8')
        concatenated = hash + self.challenge

        return b64encode(sha256(
            concatenated.encode('utf-8')).digest()).decode('utf-8')

    async def handle_identify(self, authentication):
        if authentication == self.hash_password():
            await self.send_to_streamer({
                'identified': {
                    'result': {
                        'ok':{}
                    }
                }
            })
        else:
            print('identify failed')

    async def handle_event(self, data):
        for kind, data in data.items():
            if kind == 'log':
                print(data['entry'])
            else:
                print('ignoring event', kind, data)

    async def handle_response(self, data):
        print(data)
        try:
            request_id = data['id']
            queue = self.client_completions[request_id]
            await queue.put(data)
        except Exception:
            pass

    async def handle_client(self, request):
        client = web.WebSocketResponse()
        await client.prepare(request)

        async for message in client:
            if message.type == aiohttp.WSMsgType.TEXT:
                message = json.loads(message.data)

                if message['type'] == 'request':
                    request_id = self.next_id()
                    queue = asyncio.Queue()
                    self.client_completions[request_id] = queue
                    await self.send_to_streamer({
                        'request': {
                            'id': request_id,
                            'data': message['data']
                        }
                    })
                    await client.send_str(json.dumps({
                        'type': 'response',
                        'data': await queue.get()
                    }))
                else:
                    print('Not supported', message)
            else:
                print('Ignoring', message)

        return client


def do_run(args):
    app = web.Application()
    assistant = Assistant(args.password)
    app.add_routes([web.get('/', assistant.handle_streamer)])
    app.add_routes([web.get('/client', assistant.handle_client)])
    web.run_app(app, port=args.port)


def make_client_request(port, data):
    with connect(f'ws://localhost:{port}/client') as server:
        server.send(json.dumps({
            'type': 'request',
            'data': data
        }))

        return json.loads(server.recv())['data']


def get_settings(port):
    data = make_client_request(
        port,
        {
            'getSettings': {
            }
        })

    return data['data']['getSettings']['data']


def get_scene_id(port, name):
    settings = get_settings(port)

    for scene in settings['scenes']:
        if scene['name'] == name:
            return scene['id']
    else:
        raise Exception(f'Unknown scene {name}')


def do_get_settings(args):
    print(json.dumps(get_settings(args.port), indent=4))


def do_set_zoom(args):
    make_client_request(
        args.port,
        {
            'setZoom': {
                'x': float(args.level)
            }
        })


def do_set_scene(args):
    make_client_request(
        args.port,
        {
            'setScene': {
                'id': get_scene_id(args.port, args.name)
            }
        })


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--debug', action='store_true')
    parser.add_argument('--port', type=int, default=DEFAULT_PORT)

    subparsers = parser.add_subparsers(title='subcommands',
                                       dest='subcommand')
    subparsers.required = True

    subparser = subparsers.add_parser('run')
    subparser.add_argument('--password', required=True)
    subparser.set_defaults(func=do_run)

    subparser = subparsers.add_parser('get_settings')
    subparser.set_defaults(func=do_get_settings)

    subparser = subparsers.add_parser('set_zoom')
    subparser.add_argument('level')
    subparser.set_defaults(func=do_set_zoom)

    subparser = subparsers.add_parser('set_scene')
    subparser.add_argument('name')
    subparser.set_defaults(func=do_set_scene)

    args = parser.parse_args()

    if args.debug:
        args.func(args)
    else:
        try:
            args.func(args)
        except BaseException as e:
            sys.exit('error: ' + str(e))


main()



---
File: /utils/bitrate.py
---

#!/usr/bin/env python3

import random
import time
import subprocess
import argparse


def set_speed(speed):
    print(time.ctime())
    print(f" - {speed} Mbit")
    subprocess.run(f'sudo tc qdisc replace dev eno1 root netem rate {speed}Mbit',
                   shell=True,
                   check=True)


def do_constant(args):
    set_speed(args.bitrate)


def do_square(args):
    while True:
        set_speed(args.lowbitrate)
        time.sleep(15)
        set_speed(args.highbitrate)
        time.sleep(15)


def do_random(args):
    minimum = 1.0

    while True:
        speed = round(random.random() * 10 + minimum, 1)
        set_speed(speed)
        time.sleep(15)


def main():
    parser = argparse.ArgumentParser()

    # Workaround to make the subparser required in Python 3.
    subparsers = parser.add_subparsers(title='subcommands',
                                       dest='subcommand')
    subparsers.required = True

    subparser = subparsers.add_parser('constant')
    subparser.add_argument('bitrate', type=float)
    subparser.set_defaults(func=do_constant)

    subparser = subparsers.add_parser('square')
    subparser.add_argument('lowbitrate', type=float)
    subparser.add_argument('highbitrate', type=float)
    subparser.set_defaults(func=do_square)

    subparser = subparsers.add_parser('random')
    subparser.set_defaults(func=do_random)

    args = parser.parse_args()
    args.func(args)


main()



---
File: /utils/translate.py
---

import sys
import json
from pathlib import Path
from deep_translator import GoogleTranslator

LANGUAGES = [
    ("sv", "sv"),
    ("es", "es"),
    ("de", "de"),
    ("fi", "fi"),
    ("fr", "fr"),
    ("pl", "pl"),
    ("vi", "vi"),
    ("nl", "nl"),
    # ("zh-HK", "zh-HK"),
    ("zh-Hans", "zh-CN"),
    ("zh-Hant", "zh-TW"),
    ("el", "el"),
    ("tr", "tr"),
    ("pt-BR", "pt"),
    ("pt-PT", "pt"),
    ("id", "id"),
    ("it", "it"),
    ("ja", "ja"),
    ("hi", "hi"),
    ("ko", "ko"),
    ("ru", "ru"),
    ("uk", "uk")
]


def needs_translation(item):
    state = item['stringUnit']['state']

    return state not in ['translated', 'needs_review']


def main():
    localizable_xcstrings_path = Path(sys.argv[1])
    localizable = json.loads(localizable_xcstrings_path.read_text())

    try:
        for english, value in localizable['strings'].items():
            localizations = value.get('localizations')

            if localizations is None:
                localizations = {}
                value['localizations'] = localizations

            for xcode_language, google_language in LANGUAGES:
                item = localizations.get(xcode_language)

                if item is None or needs_translation(item):
                    if not english.strip():
                        continue

                    print(f'Translating "{english}" to {xcode_language}')
                    translator = GoogleTranslator(source='en', target=google_language)
                    translated = translator.translate(english)
                    localizations[xcode_language] = {
                        'stringUnit': {
                            'state': 'needs_review',
                            'value': translated
                        }
                    }
    finally:
        localizable_xcstrings_path.write_text(
            json.dumps(localizable,
                       indent=2,
                       separators=(',', ' : ')))


main()



---
File: /utils/xliff.py
---

import argparse
from xml.etree import ElementTree

NS = {
    '': "urn:oasis:names:tc:xliff:document:1.2"
}

ElementTree.register_namespace('', "urn:oasis:names:tc:xliff:document:1.2")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('xliff')
    args = parser.parse_args()

    tree = ElementTree.parse(args.xliff)

    for body in tree.findall('./file/body', namespaces=NS):
        sorted_trans_units = []

        for trans_unit in body.findall('./trans-unit', namespaces=NS):
            target = trans_unit.find("./target", namespaces=NS)

            if target is None:
                sorted_trans_units.insert(0, trans_unit)
            else:
                if target.attrib.get('state') == 'translated':
                    sorted_trans_units.append(trans_unit)
                else:
                    sorted_trans_units.insert(0, trans_unit)

        body.clear()
        body.extend(sorted_trans_units)

    ElementTree.indent(tree)
    tree.write(args.xliff, xml_declaration=True, encoding='utf-8')


main()

